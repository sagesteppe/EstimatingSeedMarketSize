if(missing(save)){save <- TRUE}
if(missing(conf_lvl)){conf_lvl <- 0.95}
rolled <- avg(x, ...)
form <- as.formula(
paste(colnames(rolled)[grep('roll_.*$', colnames(rolled))], "~", 'FIRE_YEAR'))
modr2 <- lm(form, data = rolled)
gr <- data.frame(
# only operate on years within the rolling average.
FIRE_YEAR =  seq(min(rolled[!is.na(rolled$roll), 'FIRE_YEAR']),
max(rolled$FIRE_YEAR))
)
return(gr)
pred_help <- function(y, lvl, gr){
mod_pred <- data.frame(
FIRE_YEAR = gr,
predict.lm(
y, gr, interval = 'confidence', level = lvl)
)
return(mod_pred)
}
p <- pred_help(modr2, lvl = conf_lvl, gr)
p$observed <- x$TotalArea_Acre
state = vector(mode = 'character', length = nrow(p))
for (i in 1:nrow(p)){
if(p$observed[i] <= p$fit[i]){state[i] = 'below'}  else {state[i] = 'above'}
}
# first we need to calculate the transition probabilities between the various states.
# Doing this is not super well documented in the `markovchain` package, but the
# function `markovchainFit` will develop transition probabilities.
# The input object works in pairs, essentially position 1 x[1] is state 1, and
# position 2 x[2] is state 2, the 3rd and 4th positions refer to an entirely new
# set of observations.
mcFitMLE <- markovchain::markovchainFit(state, method = 'mle')
# we create another s4 object which the package relies on using base R's `new`
# function
fire_chain <- new(
"markovchain",
states = c('above', 'below'),
transitionMatrix = mcFitMLE[["estimate"]]@transitionMatrix, # access the transition matrix
name = "Fire Chain - Relative to Regression fit")
# save the original data object.
# many more years are below the fire amount than are
# above the trend line is largely informed by a few large fires.
# we can repeat this process n times.
set.seed(1428)
markov_sim <- replicate(100, expr =
markovchain::markovchainSequence(
n = 10,  # number of years into future.
markovchain = fire_chain # chain object.
)
)
markov_sim <- as.data.frame(markov_sim)
colnames(markov_sim) <- paste0('S', 1:ncol(markov_sim))
return(
list(
chain = fire_chain,
steadyStates = markovchain::steadyStates(fire_chain),
markov_simulations = markov_sim
)
)
write.csv()
}
x <- classifyPtsMarkov(ann_cgb, colname = 'TotalArea_Acre', w = 1, type = 'g')
View(x)
#' @description Wrapper function to fit a linear model and predict it onto a matrix
#' and classify the training data as being in one of three or optionally three classes.
#' 'below' for all points beneath the lower confidence limit, 'around' for
#' points within the confidence limit, and 'upper' for points above the upper 95% confidence limit.
#' @param x Dataframe. The data set to be analysed.
#' @param interval Character Vector. The type of interval to be used for
#' calculating distance between, defaults to 'confidence' the other option is 'prediction'.
#' @param conf_lvl Numeric. The confidence level to calculate the confidence limits at, defaults to 0.95 for a 95% confidence interval.
#' @param save Boolean. Whether to save objects to disk or just return locally. Defaults to TRUE.
#' @export
classifyPtsMarkov <- function(x, w, interval, conf_lvl, prediction, type, save, ...){
if(missing(interval)){interval <- 'confidence'}
if(missing(prediction)){prediction <- 'fit'}
if(missing(save)){save <- TRUE}
if(missing(conf_lvl)){conf_lvl <- 0.95}
rolled <- avg(x, ...)
form <- as.formula(
paste(colnames(rolled)[grep('roll_.*$', colnames(rolled))], "~", 'FIRE_YEAR'))
modr2 <- lm(form, data = rolled)
gr <- data.frame(
# only operate on years within the rolling average.
FIRE_YEAR =  seq(min(rolled[!is.na(rolled$roll), 'FIRE_YEAR']),
max(rolled$FIRE_YEAR))
)
pred_help <- function(y, lvl, gr){
mod_pred <- data.frame(
FIRE_YEAR = gr,
predict.lm(
y, gr, interval = 'confidence', level = lvl)
)
return(mod_pred)
}
p <- pred_help(modr2, lvl = conf_lvl, gr)
return(p)
p$observed <- x$TotalArea_Acre
state = vector(mode = 'character', length = nrow(p))
for (i in 1:nrow(p)){
if(p$observed[i] <= p$fit[i]){state[i] = 'below'}  else {state[i] = 'above'}
}
# first we need to calculate the transition probabilities between the various states.
# Doing this is not super well documented in the `markovchain` package, but the
# function `markovchainFit` will develop transition probabilities.
# The input object works in pairs, essentially position 1 x[1] is state 1, and
# position 2 x[2] is state 2, the 3rd and 4th positions refer to an entirely new
# set of observations.
mcFitMLE <- markovchain::markovchainFit(state, method = 'mle')
# we create another s4 object which the package relies on using base R's `new`
# function
fire_chain <- new(
"markovchain",
states = c('above', 'below'),
transitionMatrix = mcFitMLE[["estimate"]]@transitionMatrix, # access the transition matrix
name = "Fire Chain - Relative to Regression fit")
# save the original data object.
# many more years are below the fire amount than are
# above the trend line is largely informed by a few large fires.
# we can repeat this process n times.
set.seed(1428)
markov_sim <- replicate(100, expr =
markovchain::markovchainSequence(
n = 10,  # number of years into future.
markovchain = fire_chain # chain object.
)
)
markov_sim <- as.data.frame(markov_sim)
colnames(markov_sim) <- paste0('S', 1:ncol(markov_sim))
return(
list(
chain = fire_chain,
steadyStates = markovchain::steadyStates(fire_chain),
markov_simulations = markov_sim
)
)
write.csv()
}
x <- classifyPtsMarkov(ann_cgb, colname = 'TotalArea_Acre', w = 1, type = 'g')
#' @description Wrapper function to fit a linear model and predict it onto a matrix
#' and classify the training data as being in one of three or optionally three classes.
#' 'below' for all points beneath the lower confidence limit, 'around' for
#' points within the confidence limit, and 'upper' for points above the upper 95% confidence limit.
#' @param x Dataframe. The data set to be analysed.
#' @param interval Character Vector. The type of interval to be used for
#' calculating distance between, defaults to 'confidence' the other option is 'prediction'.
#' @param conf_lvl Numeric. The confidence level to calculate the confidence limits at, defaults to 0.95 for a 95% confidence interval.
#' @param save Boolean. Whether to save objects to disk or just return locally. Defaults to TRUE.
#' @export
classifyPtsMarkov <- function(x, w, interval, conf_lvl, prediction, type, save, ...){
if(missing(interval)){interval <- 'confidence'}
if(missing(prediction)){prediction <- 'fit'}
if(missing(save)){save <- TRUE}
if(missing(conf_lvl)){conf_lvl <- 0.95}
rolled <- avg(x, ...)
rl_col <- colnames(rolled)[grep('roll_.*$', colnames(rolled))]
form <- as.formula(rl_col, "~", 'FIRE_YEAR')
modr2 <- lm(form, data = rolled)
gr <- data.frame(
# only operate on years within the rolling average.
FIRE_YEAR =  seq(min(rolled[!is.na(rolled[rl_col]), 'FIRE_YEAR']),
max(rolled$FIRE_YEAR))
)
pred_help <- function(y, lvl, gr){
mod_pred <- data.frame(
FIRE_YEAR = gr,
predict.lm(
y, gr, interval = 'confidence', level = lvl)
)
return(mod_pred)
}
p <- pred_help(modr2, lvl = conf_lvl, gr)
return(p)
p$observed <- x$TotalArea_Acre
is.na(rolled$)
#' @description Wrapper function to fit a linear model and predict it onto a matrix
#' and classify the training data as being in one of three or optionally three classes.
#' 'below' for all points beneath the lower confidence limit, 'around' for
#' points within the confidence limit, and 'upper' for points above the upper 95% confidence limit.
#' @param x Dataframe. The data set to be analysed.
#' @param interval Character Vector. The type of interval to be used for
#' calculating distance between, defaults to 'confidence' the other option is 'prediction'.
#' @param conf_lvl Numeric. The confidence level to calculate the confidence limits at, defaults to 0.95 for a 95% confidence interval.
#' @param save Boolean. Whether to save objects to disk or just return locally. Defaults to TRUE.
#' @export
classifyPtsMarkov <- function(x, w, interval, conf_lvl, prediction, type, save, ...){
if(missing(interval)){interval <- 'confidence'}
if(missing(prediction)){prediction <- 'fit'}
if(missing(save)){save <- TRUE}
if(missing(conf_lvl)){conf_lvl <- 0.95}
rolled <- avg(x, ...)
rl_col <- colnames(rolled)[grep('roll_.*$', colnames(rolled))]
form <- as.formula(rl_col, "~", 'FIRE_YEAR')
modr2 <- lm(form, data = rolled)
gr <- data.frame(
# only operate on years within the rolling average.
FIRE_YEAR =  seq(min(rolled[!is.na(rolled[rl_col]), 'FIRE_YEAR']),
max(rolled$FIRE_YEAR))
)
pred_help <- function(y, lvl, gr){
mod_pred <- data.frame(
FIRE_YEAR = gr,
predict.lm(
y, gr, interval = 'confidence', level = lvl)
)
return(mod_pred)
}
p <- pred_help(modr2, lvl = conf_lvl, gr)
return(p)
p$observed <- x$TotalArea_Acre
#  is.na(rolled$)
state = vector(mode = 'character', length = nrow(p))
for (i in 1:nrow(p)){
if(p$observed[i] <= p$fit[i]){state[i] = 'below'}  else {state[i] = 'above'}
}
# first we need to calculate the transition probabilities between the various states.
# Doing this is not super well documented in the `markovchain` package, but the
# function `markovchainFit` will develop transition probabilities.
# The input object works in pairs, essentially position 1 x[1] is state 1, and
# position 2 x[2] is state 2, the 3rd and 4th positions refer to an entirely new
# set of observations.
mcFitMLE <- markovchain::markovchainFit(state, method = 'mle')
# we create another s4 object which the package relies on using base R's `new`
# function
fire_chain <- new(
"markovchain",
states = c('above', 'below'),
transitionMatrix = mcFitMLE[["estimate"]]@transitionMatrix, # access the transition matrix
name = "Fire Chain - Relative to Regression fit")
# save the original data object.
# many more years are below the fire amount than are
# above the trend line is largely informed by a few large fires.
# we can repeat this process n times.
set.seed(1428)
markov_sim <- replicate(100, expr =
markovchain::markovchainSequence(
n = 10,  # number of years into future.
markovchain = fire_chain # chain object.
)
)
markov_sim <- as.data.frame(markov_sim)
colnames(markov_sim) <- paste0('S', 1:ncol(markov_sim))
return(
list(
chain = fire_chain,
steadyStates = markovchain::steadyStates(fire_chain),
markov_simulations = markov_sim
)
)
write.csv()
}
x <- classifyPtsMarkov(ann_cgb, colname = 'TotalArea_Acre', w = 1, type = 'g')
rl_col
#' @description Wrapper function to fit a linear model and predict it onto a matrix
#' and classify the training data as being in one of three or optionally three classes.
#' 'below' for all points beneath the lower confidence limit, 'around' for
#' points within the confidence limit, and 'upper' for points above the upper 95% confidence limit.
#' @param x Dataframe. The data set to be analysed.
#' @param interval Character Vector. The type of interval to be used for
#' calculating distance between, defaults to 'confidence' the other option is 'prediction'.
#' @param conf_lvl Numeric. The confidence level to calculate the confidence limits at, defaults to 0.95 for a 95% confidence interval.
#' @param save Boolean. Whether to save objects to disk or just return locally. Defaults to TRUE.
#' @export
classifyPtsMarkov <- function(x, w, interval, conf_lvl, prediction, type, save, ...){
if(missing(interval)){interval <- 'confidence'}
if(missing(prediction)){prediction <- 'fit'}
if(missing(save)){save <- TRUE}
if(missing(conf_lvl)){conf_lvl <- 0.95}
rolled <- avg(x, ...)
rl_col <- colnames(rolled)[grep('roll_.*$', colnames(rolled))]
form <- as.formula(paste0(rl_col, "~", 'FIRE_YEAR'))
modr2 <- lm(form, data = rolled)
gr <- data.frame(
# only operate on years within the rolling average.
FIRE_YEAR =  seq(min(rolled[!is.na(rolled[rl_col]), 'FIRE_YEAR']),
max(rolled$FIRE_YEAR))
)
pred_help <- function(y, lvl, gr){
mod_pred <- data.frame(
FIRE_YEAR = gr,
predict.lm(
y, gr, interval = 'confidence', level = lvl)
)
return(mod_pred)
}
p <- pred_help(modr2, lvl = conf_lvl, gr)
return(p)
p$observed <- x$TotalArea_Acre
#  is.na(rolled$)
state = vector(mode = 'character', length = nrow(p))
for (i in 1:nrow(p)){
if(p$observed[i] <= p$fit[i]){state[i] = 'below'}  else {state[i] = 'above'}
}
# first we need to calculate the transition probabilities between the various states.
# Doing this is not super well documented in the `markovchain` package, but the
# function `markovchainFit` will develop transition probabilities.
# The input object works in pairs, essentially position 1 x[1] is state 1, and
# position 2 x[2] is state 2, the 3rd and 4th positions refer to an entirely new
# set of observations.
mcFitMLE <- markovchain::markovchainFit(state, method = 'mle')
# we create another s4 object which the package relies on using base R's `new`
# function
fire_chain <- new(
"markovchain",
states = c('above', 'below'),
transitionMatrix = mcFitMLE[["estimate"]]@transitionMatrix, # access the transition matrix
name = "Fire Chain - Relative to Regression fit")
# save the original data object.
# many more years are below the fire amount than are
# above the trend line is largely informed by a few large fires.
# we can repeat this process n times.
set.seed(1428)
markov_sim <- replicate(100, expr =
markovchain::markovchainSequence(
n = 10,  # number of years into future.
markovchain = fire_chain # chain object.
)
)
markov_sim <- as.data.frame(markov_sim)
colnames(markov_sim) <- paste0('S', 1:ncol(markov_sim))
return(
list(
chain = fire_chain,
steadyStates = markovchain::steadyStates(fire_chain),
markov_simulations = markov_sim
)
)
write.csv()
}
x <- classifyPtsMarkov(ann_cgb, colname = 'TotalArea_Acre', w = 1, type = 'g')
x
#' @description Wrapper function to fit a linear model and predict it onto a matrix
#' and classify the training data as being in one of three or optionally three classes.
#' 'below' for all points beneath the lower confidence limit, 'around' for
#' points within the confidence limit, and 'upper' for points above the upper 95% confidence limit.
#' @param x Dataframe. The data set to be analysed.
#' @param interval Character Vector. The type of interval to be used for
#' calculating distance between, defaults to 'confidence' the other option is 'prediction'.
#' @param conf_lvl Numeric. The confidence level to calculate the confidence limits at, defaults to 0.95 for a 95% confidence interval.
#' @param save Boolean. Whether to save objects to disk or just return locally. Defaults to TRUE.
#' @export
classifyPtsMarkov <- function(x, w, interval, conf_lvl, prediction, type, save, ...){
if(missing(interval)){interval <- 'confidence'}
if(missing(prediction)){prediction <- 'fit'}
if(missing(save)){save <- TRUE}
if(missing(conf_lvl)){conf_lvl <- 0.95}
rolled <- avg(x, ...)
rl_col <- colnames(rolled)[grep('roll_.*$', colnames(rolled))]
form <- as.formula(paste0(rl_col, "~", 'FIRE_YEAR'))
modr2 <- lm(form, data = rolled)
gr <- data.frame(
# only operate on years within the rolling average.
FIRE_YEAR =  seq(min(rolled[!is.na(rolled[rl_col]), 'FIRE_YEAR']),
max(rolled$FIRE_YEAR))
)
pred_help <- function(y, lvl, gr){
mod_pred <- data.frame(
FIRE_YEAR = gr,
predict.lm(
y, gr, interval = 'confidence', level = lvl)
)
return(mod_pred)
}
p <- pred_help(modr2, lvl = conf_lvl, gr)
p$observed <- x[!is.na(rolled[rl_col], 'TotalArea_Acre')]
state = vector(mode = 'character', length = nrow(p))
for (i in 1:nrow(p)){
if(p$observed[i] <= p$fit[i]){state[i] = 'below'}  else {state[i] = 'above'}
}
# first we need to calculate the transition probabilities between the various states.
# Doing this is not super well documented in the `markovchain` package, but the
# function `markovchainFit` will develop transition probabilities.
# The input object works in pairs, essentially position 1 x[1] is state 1, and
# position 2 x[2] is state 2, the 3rd and 4th positions refer to an entirely new
# set of observations.
mcFitMLE <- markovchain::markovchainFit(state, method = 'mle')
# we create another s4 object which the package relies on using base R's `new`
# function
fire_chain <- new(
"markovchain",
states = c('above', 'below'),
transitionMatrix = mcFitMLE[["estimate"]]@transitionMatrix, # access the transition matrix
name = "Fire Chain - Relative to Regression fit")
# save the original data object.
# many more years are below the fire amount than are
# above the trend line is largely informed by a few large fires.
# we can repeat this process n times.
set.seed(1428)
markov_sim <- replicate(100, expr =
markovchain::markovchainSequence(
n = 10,  # number of years into future.
markovchain = fire_chain # chain object.
)
)
markov_sim <- as.data.frame(markov_sim)
colnames(markov_sim) <- paste0('S', 1:ncol(markov_sim))
return(
list(
chain = fire_chain,
steadyStates = markovchain::steadyStates(fire_chain),
markov_simulations = markov_sim
)
)
write.csv()
}
x <- classifyPtsMarkov(ann_cgb, colname = 'TotalArea_Acre', w = 1, type = 'g')
#' @description Wrapper function to fit a linear model and predict it onto a matrix
#' and classify the training data as being in one of three or optionally three classes.
#' 'below' for all points beneath the lower confidence limit, 'around' for
#' points within the confidence limit, and 'upper' for points above the upper 95% confidence limit.
#' @param x Dataframe. The data set to be analysed.
#' @param interval Character Vector. The type of interval to be used for
#' calculating distance between, defaults to 'confidence' the other option is 'prediction'.
#' @param conf_lvl Numeric. The confidence level to calculate the confidence limits at, defaults to 0.95 for a 95% confidence interval.
#' @param save Boolean. Whether to save objects to disk or just return locally. Defaults to TRUE.
#' @export
classifyPtsMarkov <- function(x, w, interval, conf_lvl, prediction, type, save, ...){
if(missing(interval)){interval <- 'confidence'}
if(missing(prediction)){prediction <- 'fit'}
if(missing(save)){save <- TRUE}
if(missing(conf_lvl)){conf_lvl <- 0.95}
rolled <- avg(x, ...)
rl_col <- colnames(rolled)[grep('roll_.*$', colnames(rolled))]
form <- as.formula(paste0(rl_col, "~", 'FIRE_YEAR'))
modr2 <- lm(form, data = rolled)
gr <- data.frame(
# only operate on years within the rolling average.
FIRE_YEAR =  seq(min(rolled[!is.na(rolled[rl_col]), 'FIRE_YEAR']),
max(rolled$FIRE_YEAR))
)
pred_help <- function(y, lvl, gr){
mod_pred <- data.frame(
FIRE_YEAR = gr,
predict.lm(
y, gr, interval = 'confidence', level = lvl)
)
return(mod_pred)
}
p <- pred_help(modr2, lvl = conf_lvl, gr)
p$observed <- x[!is.na(rolled[rl_col]), 'TotalArea_Acre']
state = vector(mode = 'character', length = nrow(p))
for (i in 1:nrow(p)){
if(p$observed[i] <= p$fit[i]){state[i] = 'below'}  else {state[i] = 'above'}
}
# first we need to calculate the transition probabilities between the various states.
# Doing this is not super well documented in the `markovchain` package, but the
# function `markovchainFit` will develop transition probabilities.
# The input object works in pairs, essentially position 1 x[1] is state 1, and
# position 2 x[2] is state 2, the 3rd and 4th positions refer to an entirely new
# set of observations.
mcFitMLE <- markovchain::markovchainFit(state, method = 'mle')
# we create another s4 object which the package relies on using base R's `new`
# function
fire_chain <- new(
"markovchain",
states = c('above', 'below'),
transitionMatrix = mcFitMLE[["estimate"]]@transitionMatrix, # access the transition matrix
name = "Fire Chain - Relative to Regression fit")
# save the original data object.
# many more years are below the fire amount than are
# above the trend line is largely informed by a few large fires.
# we can repeat this process n times.
set.seed(1428)
markov_sim <- replicate(100, expr =
markovchain::markovchainSequence(
n = 10,  # number of years into future.
markovchain = fire_chain # chain object.
)
)
markov_sim <- as.data.frame(markov_sim)
colnames(markov_sim) <- paste0('S', 1:ncol(markov_sim))
return(
list(
chain = fire_chain,
steadyStates = markovchain::steadyStates(fire_chain),
markov_simulations = markov_sim
)
)
write.csv()
}
x <- classifyPtsMarkov(ann_cgb, colname = 'TotalArea_Acre', w = 1, type = 'g')
View(x)
x[["chain"]]
#'
#' @param x Dataframe. The data set to be analysed.
#' @param w Numeric. The rolling window to use for the calculation. Defaults to 3.
#' Defaults to 1, which is that no rolling average is used.
#' @param interval Character Vector. The type of interval to be used for
#' calculating distance between, defaults to 'confidence' the other option is 'prediction'.
#' @param prediction Vector. the name of the column from the fit model to use for
#' calculating the distance between. Defaults to 'fit', other options are: 'lwr', and 'upr'.
#' @param conf_lvl Numeric. The confidence level to calculate the confidence limits at, defaults to 0.95 for a 95% confidence interval.
#' @export
reportBalance <- function(x, w, interval, prediction, conf_lvl){
if(missing(interval)){interval <- 'confidence'}
if(missing(prediction)){prediction <- 'fit'}
if(missing(conf_lvl)){conf_lvl <- 0.95}
if(missing(w)){w <- 1}
rolled <- avg(x, w = w, ...)
rl_col <- colnames(rolled)[grep('roll_.*$', colnames(rolled))]
form <- as.formula(paste0(rl_col, "~", 'FIRE_YEAR'))
modr2 <- lm(form, data = rolled)
gr <- data.frame(
# only operate on years within the rolling average.
FIRE_YEAR =  seq(min(rolled[!is.na(rolled$roll), 'FIRE_YEAR']),
max(rolled$FIRE_YEAR))
)
p <- pred_help(modr2, conf_lvl, interval)
ob <- AreaDeficitSummary(p, rolled, prediction)
TreatableAreaPlots(x = ob, rolled, mod = p, colname = 'fit', yr_roll = yr_roll)
}
