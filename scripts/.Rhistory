plot(
return_ls$Period, return_ls$estimate, type = 'l',
ylim = c(min(return_ls$lwrCI), max(return_ls$uprCI)),
main = 'Annual Fire Return Intervals', xlab = 'Return Interval', ylab = 'Area (Acres)'
)
lines(return_ls$Period, return_ls$uprCI, lty = 2)
lines(return_ls$Period, return_ls$lwrCI, lty = 2)
points(return_ls$Period[positions], return_ls$estimate[positions], alpha = 0.1)
plot(
return_ls$Period, return_ls$estimate, type = 'l',
ylim = c(min(return_ls$lwrCI), max(return_ls$uprCI)),
main = 'Annual Fire Return Intervals', xlab = 'Return Interval', ylab = 'Area (Acres)'
)
lines(return_ls$Period, return_ls$uprCI, lty = 2)
lines(return_ls$Period, return_ls$lwrCI, lty = 2)
points(return_ls$Period[positions], return_ls$estimate[positions])
positions <- sort( # sampling rows from the data frame based on the return intervals
sample(1:nrow(return_ls),
prob = return_ls$Pr,
size = 100, replace = TRUE))
plot(density( sort(return_ls[positions,'Pr']) ))
plot(
return_ls$Period, return_ls$estimate, type = 'l',
ylim = c(min(return_ls$lwrCI), max(return_ls$uprCI)),
main = 'Annual Fire Return Intervals', xlab = 'Return Interval', ylab = 'Area (Acres)'
)
lines(return_ls$Period, return_ls$uprCI, lty = 2)
lines(return_ls$Period, return_ls$lwrCI, lty = 2)
points(return_ls$Period[positions], return_ls$estimate[positions])
View(ak)
ak$total
ak$TotalArea_Acre
?abline
plot(
return_ls$Period, return_ls$estimate, type = 'l',
ylim = c(min(return_ls$lwrCI), max(return_ls$uprCI)),
main = 'Annual Fire Return Intervals', xlab = 'Return Interval', ylab = 'Area (Acres)'
)
lines(return_ls$Period, return_ls$uprCI, lty = 2)
lines(return_ls$Period, return_ls$lwrCI, lty = 2)
for (i in 1:seq_along(length(ak$TotalArea_Acre))){
abline(h = ak$TotalArea_Acre[i])
}
plot(
return_ls$Period, return_ls$estimate, type = 'l',
ylim = c(min(return_ls$lwrCI), max(return_ls$uprCI)),
main = 'Annual Fire Return Intervals', xlab = 'Return Interval', ylab = 'Area (Acres)'
)
lines(return_ls$Period, return_ls$uprCI, lty = 2)
lines(return_ls$Period, return_ls$lwrCI, lty = 2)
for (i in 1:seq_along(length(ak$TotalArea_Acre))){
abline(h = ak$TotalArea_Acre[i], col = 'red')
}
ak$TotalArea_Acre
for (i in 1:seq_along(length(ak$TotalArea_Acre))){
ak$TotalArea_Acre[i]
# abline(h = ak$TotalArea_Acre[i], col = 'red')
}
print(ak$TotalArea_Acre[i])
1:seq_along(length(ak$TotalArea_Acre)
1:seq(length(ak$TotalArea_Acre))
1:seq(length(ak$TotalArea_Acre))
length(ak$TotalArea_Acre))
length(ak$TotalArea_Acre)
1:seq(length(ak$TotalArea_Acre))
1:seq(nrow(ak))
1:nrow(ak)
for (i in 1:nrow(ak)){
print(ak$TotalArea_Acre[i])
# abline(h = ak$TotalArea_Acre[i], col = 'red')
}
plot(
return_ls$Period, return_ls$estimate, type = 'l',
ylim = c(min(return_ls$lwrCI), max(return_ls$uprCI)),
main = 'Annual Fire Return Intervals', xlab = 'Return Interval', ylab = 'Area (Acres)'
)
lines(return_ls$Period, return_ls$uprCI, lty = 2)
lines(return_ls$Period, return_ls$lwrCI, lty = 2)
for (i in 1:nrow(ak)){
abline(h = ak$TotalArea_Acre[i], col = 'red')
}
for (i in 1:nrow(ak)){
abline(h = ak$TotalArea_Acre[i], col = 'red', lty = 3)
}
plot(
return_ls$Period, return_ls$estimate, type = 'l',
ylim = c(min(return_ls$lwrCI), max(return_ls$uprCI)),
main = 'Annual Fire Return Intervals', xlab = 'Return Interval', ylab = 'Area (Acres)'
)
lines(return_ls$Period, return_ls$uprCI, lty = 2)
lines(return_ls$Period, return_ls$lwrCI, lty = 2)
for (i in 1:nrow(ak)){
abline(h = ak$TotalArea_Acre[i], col = 'red', lty = 3)
}
plot(
return_ls$Period, return_ls$estimate, type = 'l',
ylim = c(min(return_ls$lwrCI), max(return_ls$uprCI)),
main = 'Annual Fire Return Intervals', xlab = 'Return Interval', ylab = 'Area (Acres)'
)
for (i in 1:nrow(ak)){
abline(h = ak$TotalArea_Acre[i], col = 'red', lty = 3)
}
lines(return_ls$Period, return_ls$uprCI, lty = 2)
lines(return_ls$Period, return_ls$lwrCI, lty = 2)
plot(
return_ls$Period, return_ls$estimate, type = 'l',
ylim = c(min(return_ls$lwrCI), max(return_ls$uprCI)),
main = 'Annual Fire Return Intervals', xlab = 'Return Interval', ylab = 'Area (Acres)'
)
for (i in 1:nrow(ak)){
segments(
x0 = 0, x1 = 5, y = ak$TotalArea_Acre[i], col = 'red', lty = 3)
}
plot(
return_ls$Period, return_ls$estimate, type = 'l',
ylim = c(min(return_ls$lwrCI), max(return_ls$uprCI)),
main = 'Annual Fire Return Intervals', xlab = 'Return Interval', ylab = 'Area (Acres)'
)
for (i in 1:nrow(ak)){
segments(
x0 = 0, x1 = 5, y0 = ak$TotalArea_Acre[i], col = 'red', lty = 3)
}
lines(return_ls$Period, return_ls$uprCI, lty = 2)
lines(return_ls$Period, return_ls$lwrCI, lty = 2)
View(annual)
ak <- filter(annual, REG_NAME == 'California-Great Basin' & NoFire > 0)
plot(ak$FIRE_YEAR, ak$TotalArea_Acre)
ak_ext <- fevd(
log(ak$TotalArea_Acre),
type = 'GEV',
units ='Acres',
span = length(ak$TotalArea_Acre),
time.units = '1/year')
plot(ak_ext)
ob <- ci(ak_ext, type = "parameter", method = 'boot')
ret_period <- seq(1.1, 99, 0.01) # 'years' for the return intervals.
return_ls <- return.level(ak_ext, ret_period, do.ci = TRUE, burn.in = 100)
#Find the intersection of the desired value and the generated sequence of return levels
return_ls <- data.frame(
Period = ret_period,
Pr = 1 - (ret_period/100),
lwrCI = return_ls[,1],
estimate = return_ls[,2],
uprCI = return_ls[,3]
)
cols <- c('lwrCI', 'uprCI', 'estimate')
return_ls[,cols] <- apply(return_ls[,cols], 2, exp)
positions <- sort( # sampling rows from the data frame based on the return intervals
sample(1:nrow(return_ls),
prob = return_ls$Pr,
size = 100, replace = TRUE))
plot(density( sort(return_ls[positions,'Pr']) ))
plot(
return_ls$Period, return_ls$estimate, type = 'l',
ylim = c(min(return_ls$lwrCI), max(return_ls$uprCI)),
main = 'Annual Fire Return Intervals', xlab = 'Return Interval', ylab = 'Area (Acres)'
)
for (i in 1:nrow(ak)){
segments(
x0 = 0, x1 = 5, y0 = ak$TotalArea_Acre[i], col = 'red', lty = 3)
}
lines(return_ls$Period, return_ls$uprCI, lty = 2)
lines(return_ls$Period, return_ls$lwrCI, lty = 2)
positions <- sort( # sampling rows from the data frame based on the return intervals
sample(1:nrow(return_ls),
prob = return_ls$Pr,
size = 1000, replace = TRUE))
plot(density( sort(return_ls[positions,'Pr']) ))
plot(
return_ls$Period, return_ls$estimate, type = 'l',
ylim = c(min(return_ls$lwrCI), max(return_ls$uprCI)),
main = 'Annual Fire Return Intervals', xlab = 'Return Interval', ylab = 'Area (Acres)'
)
for (i in 1:nrow(ak)){
segments(
x0 = 0, x1 = 5, y0 = ak$TotalArea_Acre[i], col = 'red', lty = 3)
}
lines(return_ls$Period, return_ls$uprCI, lty = 2)
lines(return_ls$Period, return_ls$lwrCI, lty = 2)
View(return_ls)
View(ak)
plot(
return_ls$Period, return_ls$estimate, type = 'l',
ylim = c(min(return_ls$lwrCI), max(return_ls$uprCI)),
main = 'Annual Fire Return Intervals', xlab = 'Return Interval', ylab = 'Area (Acres)'
)
for (i in 1:nrow(ak)){
segments(
x0 = 0, x1 = 5, y0 = ak$TotalArea_Acre[i], col = 'red')
}
lines(return_ls$Period, return_ls$uprCI, lty = 2)
lines(return_ls$Period, return_ls$lwrCI, lty = 2)
ak[1,]
ak[1,'TotalArea_Acre']
ak[1,'TotalArea_Acre'] - return_ls$estimate
abs(ak[1,'TotalArea_Acre'] - return_ls$estimate)
which.min(abs(ak[1,'TotalArea_Acre'] - return_ls$estimate))
return_ls[ which.min(abs(ak[1,'TotalArea_Acre'] - return_ls$estimate)), ]
return_ls[ which.min(abs(ak[1,'TotalArea_Acre'] - return_ls$estimate)), 'estimate']
plot(
return_ls$Period, return_ls$estimate, type = 'l',
ylim = c(min(return_ls$lwrCI), max(return_ls$uprCI)),
main = 'Annual Fire Return Intervals', xlab = 'Return Interval', ylab = 'Area (Acres)'
)
# let's draw each line from the intercept on x to the estimate on X.
for (i in 1:nrow(ak)){
segments(
x0 = 0,
x1 = return_ls[ which.min(abs(ak[i,'TotalArea_Acre'] - return_ls$estimate)), 'estimate'],
y0 = ak$TotalArea_Acre[i], col = 'red')
}
lines(return_ls$Period, return_ls$uprCI, lty = 2)
lines(return_ls$Period, return_ls$lwrCI, lty = 2)
for (i in 1:nrow(ak)){
ak[i,'TotalArea_Acre']
# segments(
#    x0 = 0,
#    x1 = return_ls[ which.min(abs(ak[i,'TotalArea_Acre'] - return_ls$estimate)), 'estimate'],
#    y0 = ak$TotalArea_Acre[i], col = 'red')
}
for (i in 1:nrow(ak)){
print ( ak[i,'TotalArea_Acre'] )
# segments(
#    x0 = 0,
#    x1 = return_ls[ which.min(abs(ak[i,'TotalArea_Acre'] - return_ls$estimate)), 'estimate'],
#    y0 = ak$TotalArea_Acre[i], col = 'red')
}
View(ak)
return_ls$estimate
# let's draw each line from the intercept on x to the estimate on X.
for (i in 1:nrow(ak)){
print (return_ls[ which.min(abs(ak[i,'TotalArea_Acre'] - return_ls$estimate)), 'estimate'])
# segments(
#    x0 = 0,
#    x1 = return_ls[ which.min(abs(ak[i,'TotalArea_Acre'] - return_ls$estimate)), 'estimate'],
#    y0 = ak$TotalArea_Acre[i], col = 'red')
}
View(ak)
plot(
return_ls$Period, return_ls$estimate, type = 'l',
ylim = c(min(return_ls$lwrCI), max(return_ls$uprCI)),
main = 'Annual Fire Return Intervals', xlab = 'Return Interval', ylab = 'Area (Acres)'
)
plot(
return_ls$Period, return_ls$estimate, type = 'l',
ylim = c(min(return_ls$lwrCI), max(return_ls$uprCI)),
main = 'Annual Fire Return Intervals', xlab = 'Return Interval', ylab = 'Area (Acres)'
)
# let's draw each line from the intercept on x to the estimate on X.
for (i in 1:nrow(ak)){
segments(
x0 = 0,
x1 = return_ls[ which.min(abs(ak[i,'TotalArea_Acre'] - return_ls$estimate)), 'Period'],
y0 = ak$TotalArea_Acre[i], col = 'red')
}
lines(return_ls$Period, return_ls$uprCI, lty = 2)
lines(return_ls$Period, return_ls$lwrCI, lty = 2)
plot(
return_ls$Period, return_ls$estimate, type = 'l',
ylim = c(min(return_ls$lwrCI), max(return_ls$uprCI)),
main = 'Annual Fire Return Intervals', xlab = 'Return Interval', ylab = 'Area (Acres)'
)
# let's draw each line from the intercept on x to the estimate on X.
for (i in 1:nrow(ak)){
segments(
x0 = 0,
x1 = return_ls[ which.min(abs(ak[i,'TotalArea_Acre'] - return_ls$estimate)), 'Period'],
y0 = ak$TotalArea_Acre[i], col = 'red', lty = 3)
}
lines(return_ls$Period, return_ls$uprCI, lty = 2)
lines(return_ls$Period, return_ls$lwrCI, lty = 2)
plot(
return_ls$Period, return_ls$estimate, type = 'l',
ylim = c(min(return_ls$lwrCI), max(return_ls$uprCI)),
main = 'Annual Fire Return Intervals', xlab = 'Return Interval', ylab = 'Area (Acres)'
)
for (i in 1:nrow(ak)){ # these are the observed fire events from the training data
segments(
x0 = 0,
x1 = return_ls[ which.min(abs(ak[i,'TotalArea_Acre'] - return_ls$estimate)), 'Period'],
y0 = ak$TotalArea_Acre[i], col = 'red', lty = 3)
}
lines(return_ls$Period, return_ls$uprCI, lty = 2)
lines(return_ls$Period, return_ls$lwrCI, lty = 2)
?segments
plot(
return_ls$Period, return_ls$estimate, type = 'l',
ylim = c(min(return_ls$lwrCI), max(return_ls$uprCI)),
main = 'Annual Fire Return Intervals', xlab = 'Return Interval', ylab = 'Area (Acres)'
)
for (i in 1:nrow(ak)){ # these are the observed fire events from the training data
segments(
x0 = 0,
x1 = return_ls[ which.min(abs(ak[i,'TotalArea_Acre'] - return_ls$estimate)), 'Period'],
y0 = ak$TotalArea_Acre[i], col = 'red', lty = 3, lwd = 0.8)
}
lines(return_ls$Period, return_ls$uprCI, lty = 2)
lines(return_ls$Period, return_ls$lwrCI, lty = 2)
?plot
plot(
return_ls$Period, return_ls$estimate, type = 'l',
ylim = c(min(return_ls$lwrCI), max(return_ls$uprCI)),
main = 'Annual Fire Return Intervals', xlab = 'Return Interval', ylab = 'Area (Acres)'
)
for (i in 1:nrow(ak)){ # these are the observed fire events from the training data
segments(
x0 = 0,
x1 = return_ls[ which.min(abs(ak[i,'TotalArea_Acre'] - return_ls$estimate)), 'Period'],
y0 = ak$TotalArea_Acre[i], col = 'red', lty = 3, lwd = 0.8)
}
lines(return_ls$Period, return_ls$uprCI, lty = 2)
lines(return_ls$Period, return_ls$lwrCI, lty = 2)
c(seq(0,10, by = 2))
seq(20, 100, by = 10)
c(seq(0,10, by = 2)), seq(20, 100, by = 10))
c(seq(0,10, by = 2), seq(20, 100, by = 10))
ticks <- c(seq(0,10, by = 2), seq(20, 100, by = 10))
axis(1, at = ticks, labels = ticks)
plot(
return_ls$Period, return_ls$estimate, type = 'l',
ylim = c(min(return_ls$lwrCI), max(return_ls$uprCI)),
main = 'Annual Fire Return Intervals', xlab = 'Return Interval', ylab = 'Area (Acres)'
)
for (i in 1:nrow(ak)){ # these are the observed fire events from the training data
segments(
x0 = 0,
x1 = return_ls[ which.min(abs(ak[i,'TotalArea_Acre'] - return_ls$estimate)), 'Period'],
y0 = ak$TotalArea_Acre[i], col = 'red', lty = 3, lwd = 0.8)
}
lines(return_ls$Period, return_ls$uprCI, lty = 2)
lines(return_ls$Period, return_ls$lwrCI, lty = 2)
axis(1, at = ticks, labels = ticks)
ticks <- c(c(0, 2, 5, 10), seq(20, 100, by = 10))
plot(
return_ls$Period, return_ls$estimate, type = 'l',
ylim = c(min(return_ls$lwrCI), max(return_ls$uprCI)),
main = 'Annual Fire Return Intervals', xlab = 'Return Interval', ylab = 'Area (Acres)'
)
for (i in 1:nrow(ak)){ # these are the observed fire events from the training data
segments(
x0 = 0,
x1 = return_ls[ which.min(abs(ak[i,'TotalArea_Acre'] - return_ls$estimate)), 'Period'],
y0 = ak$TotalArea_Acre[i], col = 'red', lty = 3, lwd = 0.8)
}
lines(return_ls$Period, return_ls$uprCI, lty = 2)
lines(return_ls$Period, return_ls$lwrCI, lty = 2)
axis(1, at = ticks, labels = ticks)
ticks <- c(c(0, 2, 5, 10), seq(20, 100, by = 20))
plot(
return_ls$Period, return_ls$estimate, type = 'l',
ylim = c(min(return_ls$lwrCI), max(return_ls$uprCI)),
main = 'Annual Fire Return Intervals', xlab = 'Return Interval', ylab = 'Area (Acres)'
)
for (i in 1:nrow(ak)){ # these are the observed fire events from the training data
segments(
x0 = 0,
x1 = return_ls[ which.min(abs(ak[i,'TotalArea_Acre'] - return_ls$estimate)), 'Period'],
y0 = ak$TotalArea_Acre[i], col = 'red', lty = 3, lwd = 0.8)
}
lines(return_ls$Period, return_ls$uprCI, lty = 2)
lines(return_ls$Period, return_ls$lwrCI, lty = 2)
axis(1, at = ticks, labels = ticks)
ticks <- c(c(0, 2, 5, 10), seq(20, 100, by = 20))
plot(
return_ls$Period, return_ls$estimate, type = 'l',
ylim = c(min(return_ls$lwrCI), max(return_ls$uprCI)),
main = 'Annual Fire Return Intervals', xlab = 'Return Interval', ylab = 'Area (Acres)'
)
for (i in 1:nrow(ak)){ # these are the observed fire events from the training data
segments(
x0 = 0,
x1 = return_ls[ which.min(abs(ak[i,'TotalArea_Acre'] - return_ls$estimate)), 'Period'],
y0 = ak$TotalArea_Acre[i], col = 'red', lty = 3, lwd = 0.8)
}
lines(return_ls$Period, return_ls$uprCI, lty = 2)
lines(return_ls$Period, return_ls$lwrCI, lty = 2)
axis(1, at = ticks, labels = ticks)
View(ak)
View(annual)
ak <- filter(annual, REG_NAME == 'Lower Colorado Basin' & NoFire > 0)
plot(ak$FIRE_YEAR, ak$TotalArea_Acre)
ak_ext <- fevd(
log(ak$TotalArea_Acre),
type = 'GEV',
units ='Acres',
span = length(ak$TotalArea_Acre),
time.units = '1/year')
plot(ak_ext)
ob <- ci(ak_ext, type = "parameter", method = 'boot')
# this allows us to obtain estimates of the fire sizes at different probabilities.
# it will work on GEV models, but assumes the data are stationary
ret_period <- seq(1.1, 99, 0.01) # 'years' for the return intervals.
return_ls <- return.level(ak_ext, ret_period, do.ci = TRUE, burn.in = 100)
#Find the intersection of the desired value and the generated sequence of return levels
return_ls <- data.frame(
Period = ret_period,
Pr = 1 - (ret_period/100),
lwrCI = return_ls[,1],
estimate = return_ls[,2],
uprCI = return_ls[,3]
)
cols <- c('lwrCI', 'uprCI', 'estimate')
return_ls[,cols] <- apply(return_ls[,cols], 2, exp)
positions <- sort( # sampling rows from the data frame based on the return intervals
sample(1:nrow(return_ls),
prob = return_ls$Pr,
size = 1000, replace = TRUE))
plot(density( sort(return_ls[positions,'Pr']) ))
ticks <- c(c(0, 2, 5, 10), seq(20, 100, by = 20))
plot(
return_ls$Period, return_ls$estimate, type = 'l',
ylim = c(min(return_ls$lwrCI), max(return_ls$uprCI)),
main = 'Annual Fire Return Intervals', xlab = 'Return Interval', ylab = 'Area (Acres)'
)
for (i in 1:nrow(ak)){ # these are the observed fire events from the training data
segments(
x0 = 0,
x1 = return_ls[which.min(abs(ak[i,'TotalArea_Acre'] - return_ls$estimate)), 'Period'],
y0 = ak$TotalArea_Acre[i], col = 'red', lty = 3, lwd = 0.8)
}
lines(return_ls$Period, return_ls$uprCI, lty = 2)
lines(return_ls$Period, return_ls$lwrCI, lty = 2)
axis(1, at = ticks, labels = ticks)
ak <- filter(annual, REG_NAME == 'Upper Colorado Basin' & NoFire > 0)
plot(ak$FIRE_YEAR, ak$TotalArea_Acre)
ak_ext <- fevd(
log(ak$TotalArea_Acre),
type = 'GEV',
units ='Acres',
span = length(ak$TotalArea_Acre),
time.units = '1/year')
plot(ak_ext)
ob <- ci(ak_ext, type = "parameter", method = 'boot')
# this allows us to obtain estimates of the fire sizes at different probabilities.
# it will work on GEV models, but assumes the data are stationary
ret_period <- seq(1.1, 99, 0.01) # 'years' for the return intervals.
return_ls <- return.level(ak_ext, ret_period, do.ci = TRUE, burn.in = 100)
#Find the intersection of the desired value and the generated sequence of return levels
return_ls <- data.frame(
Period = ret_period,
Pr = 1 - (ret_period/100),
lwrCI = return_ls[,1],
estimate = return_ls[,2],
uprCI = return_ls[,3]
)
cols <- c('lwrCI', 'uprCI', 'estimate')
return_ls[,cols] <- apply(return_ls[,cols], 2, exp)
positions <- sort( # sampling rows from the data frame based on the return intervals
sample(1:nrow(return_ls),
prob = return_ls$Pr,
size = 1000, replace = TRUE))
plot(density( sort(return_ls[positions,'Pr']) ))
ticks <- c(c(0, 2, 5, 10), seq(20, 100, by = 20))
plot(
return_ls$Period, return_ls$estimate, type = 'l',
ylim = c(min(return_ls$lwrCI), max(return_ls$uprCI)),
main = 'Annual Fire Return Intervals', xlab = 'Return Interval', ylab = 'Area (Acres)'
)
for (i in 1:nrow(ak)){ # these are the observed fire events from the training data
segments(
x0 = 0,
x1 = return_ls[which.min(abs(ak[i,'TotalArea_Acre'] - return_ls$estimate)), 'Period'],
y0 = ak$TotalArea_Acre[i], col = 'red', lty = 3, lwd = 0.8)
}
lines(return_ls$Period, return_ls$uprCI, lty = 2)
lines(return_ls$Period, return_ls$lwrCI, lty = 2)
axis(1, at = ticks, labels = ticks)
ak <- filter(annual, REG_NAME == 'Upper Colorado Basin' & NoFire > 0)
plot(ak$FIRE_YEAR, ak$TotalArea_Acre)
ak_ext <- fevd(
log(ak$TotalArea_Acre),
type = 'GEV',
units ='Acres',
span = length(ak$TotalArea_Acre),
time.units = '1/year')
plot(ak_ext)
ob <- ci(ak_ext, type = "parameter", method = 'boot')
# this allows us to obtain estimates of the fire sizes at different probabilities.
# it will work on GEV models, but assumes the data are stationary
ret_period <- seq(1.1, 99, 0.01) # 'years' for the return intervals.
return_ls <- return.level(ak_ext, ret_period, do.ci = TRUE, burn.in = 100)
#Find the intersection of the desired value and the generated sequence of return levels
return_ls <- data.frame(
Period = ret_period,
Pr = 1 - (ret_period/100),
lwrCI = return_ls[,1],
estimate = return_ls[,2],
uprCI = return_ls[,3]
)
#cols <- c('lwrCI', 'uprCI', 'estimate') # convert back to a linear scale
#return_ls[,cols] <- apply(return_ls[,cols], 2, exp)
positions <- sort( # sampling rows from the data frame based on the return intervals
sample(1:nrow(return_ls),
prob = return_ls$Pr,
size = 1000, replace = TRUE))
plot(density( sort(return_ls[positions,'Pr']) ))
ticks <- c(c(0, 2, 5, 10), seq(20, 100, by = 20))
plot(
return_ls$Period, return_ls$estimate, type = 'l',
ylim = c(min(return_ls$lwrCI), max(return_ls$uprCI)),
main = 'Annual Fire Return Intervals', xlab = 'Return Interval', ylab = 'Area (Acres)'
)
for (i in 1:nrow(ak)){ # these are the observed fire events from the training data
segments(
x0 = 0,
x1 = return_ls[which.min(abs(ak[i,'TotalArea_Acre'] - return_ls$estimate)), 'Period'],
y0 = ak$TotalArea_Acre[i], col = 'red', lty = 3, lwd = 0.8)
}
lines(return_ls$Period, return_ls$uprCI, lty = 2)
lines(return_ls$Period, return_ls$lwrCI, lty = 2)
axis(1, at = ticks, labels = ticks)
View(ak)
