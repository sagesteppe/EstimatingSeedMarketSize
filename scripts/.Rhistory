# we will manually list the fields we want in an external vector. We are going to
# pass these values into dplyr::select using dplyr::all_of, if any of these field names
# change THIS CODE WILL BREAK. It is intentional, it should be pretty easy to
# maintain this code as required: The three fields we are specifically grabbing are:
# orgnization = the name of the individual herbarium
# code = the index herbariorum code for each herbarium
# all three of the above values should be distinct, but some organizations with
# generic names should be shared.
museum_fields <- c('organization', 'code', 'division', 'department')
museums <- bind_cols(
dplyr::select(museums, dplyr::all_of(museum_fields)),
# the flattening of the json result is a little wonky, while the returned object may
# look like a data frame, it's actually a list and rstdio doesn't show it's true
# properties correctly. We can pull out data frames and info we like from them
# by subsetting with the `$` function
# we want SHIPPING addresses, not address for visitors. However...
# in some instances a postal address is not listed. We will ASSUME that when
# these are missing, that the 'physical' addres value is the appropriate value.
museums$address |>
dplyr::select(dplyr::starts_with(c('postal', 'physical'))) |>
mutate(across(where(is.character), ~ na_if(., ""))) |>
mutate(
postalStreet = ifelse(is.na(postalStreet), physicalStreet, postalStreet),
postalCity = ifelse(is.na(postalCity), physicalCity, postalCity),
postalState = ifelse(is.na(postalState), physicalState, postalState),
postalZipCode = ifelse(is.na(postalZipCode), physicalZipCode, postalZipCode),
postalCountry = 'U.S.A.' # yeah some places are missing this...
) |>
dplyr::select(dplyr::starts_with('postal')),
museums$contact
)
rm(museum_fields)
# gather some info for people, basically we want first and last names for contacts
url <- "http://sweetgum.nybg.org/science/api/v1/staff/search?country=U.S.A."
people <- jsonlite::fromJSON(url)$data
# define a look up vector again, and let's try to make sure we have the people
# designated as correspondents.
# code = the index herbariorum code for each herbarium
# correspondent = a boolean field (Yes/No), is this the person we should be emailing?
people_fields <- c( 'code', 'firstName', 'lastName', 'correspondent')
people <- bind_cols(
dplyr::select(people, dplyr::all_of(people_fields)),
people$contact
) |>
dplyr::select(-fax, -phone) # no one uses fax... the phones in the museum table look cleaner
rm(people_fields, url)
# we will join on a combination of 'code' for the herbarium and 'email' for the contact
group_by(museums, email) |>
count() |>
filter(n==2)
matches <- dplyr::left_join(museums, people, by = c('code', 'email')) |>
as.data.frame() |>
# unmarked values should be replaced with NA's
mutate(across(.cols = everything(), ~na_if(., ''))) |>
# it's a little arbitrary, but we will restrict each institute to a single phone
# number. Otherwise they will take up a lot of space on the final data form.
mutate(
phone = gsub("^(/[^1/]*_/[^1/]*)_.*$", "\\1", phone),
ID = seq_along(1:n()))
group_by(matches, email) |> # check to see if these are sensible
count() |>
filter(n==2)
# some herbaria have a default email - something like CODE@SCHOOL.EDU, this doesn't tell us
# to whom correspondence should be directed. In the case that the herbarium has a SINGLE
# correspondent in the people table, we will inject those person values into the
# contact address. Sometimes, I am sure we will get the 'wrong' person, however I think
# that the downside to these errors are negligible, especially in regards to not
# personalizing an email or designating a point of contact.
matches_on_code <- matches |>
filter(is.na(firstName)) |>
select(organization:phone, ID) |>
left_join(people, by = c('code')) |>
filter(correspondent == 'Yes')
# now add back on everything we managed to get on the first, more confident, join
matches <- bind_rows(
matches_on_code,
filter(matches, ! ID %in% matches_on_code$ID)
) |>
select(-ID)
rm(museums, people, matches_on_code)
# It seems that a few herbaria have the same point of contact. These seem reasonable
# to me. For example Dirk netz has herbaria at a couple districts on the HT forest.
# Bernie Nelsonn is the contact for both RM and the Forest service herbarium at
# WYO, and I would wager the rest of the people are in similar situations. E.G.
# THE @illinois.edu likely refers to the multiple herbaria in Urbana. NOTE that
# these comments are from 2024 and are likely to change.
# now we can join the contacts to the herbaria SOS works with.
wd <- '~/Documents/assoRted/SeedsOfSuccessHerbariumContacts/scripts'
# i am setting my
# working directory to the `scripts` folder within this Github repo. You should
# be able to readily change it to a location on your computer where the repo is cloned
# by changing the first three parts of the path ~/Documents/assoRted/'
setwd(wd) # finally set the working directory
getwd() # verify you are in the correct location
rm(wd)
# we read in appendix F
appF <- read.csv('../data/AppendixF/AppendixForiginal.csv') |>
mutate(across(where(is.character), ~ na_if(., "")))
# we need to have shipping/ contact information for all of these fields.
all_herbs <- appF$code[!is.na(appF$code)]
# these are facilities which are registered with IH. They all have info.
match_in <- filter(matches, code %in% all_herbs)
# use this to determine if we have information for all existing herbaria.
# this next list should only have BLM field offices etc in it.
# We will create those contact information.
mat_miss <- unique(all_herbs[! all_herbs %in% match_in$code])
mat_miss
rm(all_herbs, matches)
# check to see that we only have one contact per institute now..
match_in |>
group_by(code) |>
count() |>
filter(n > 1)
# Multiple contacts are present at several institutions. We will select the
# following individuals, who have worked with SOS collectors previously.
# Janeway @ CHSC
# Ackerfield @ CS
# Hughes @ GA
# Bencie @ HSC
match_in <- bind_rows(
match_in |> # subset the easy n==1 records.
group_by(code) |>
add_count() |>
filter(n == 1),
match_in |> # select our designated historic contacts
group_by(code) |>
add_count() |>
filter(n > 1 & lastName %in% c('Janeway', 'Ackerfield', 'Hughes', 'Bencie'))
) |>
arrange(code)
# some of these people need immediate updates...
# this section can probably be removed shortly.
match_in <- match_in |>
mutate(
email = ifelse(
code == 'CS' &
lastName == 'Ackerfield', 'jennifer.ackerfield@colostate.edu', email),
email = ifelse(
code == 'JEPS', 'bbaldwin@berkeley.edu', email
),
firstName = ifelse(
code == 'JEPS', 'Bruce', firstName
),
lastName = ifelse(
code == 'JEPS', 'Baldwin', lastName
),
division = ifelse(
code == 'APSC', 'Sundquist Science Complex D127', division
),
postalStreet = ifelse(
code == 'APSC', str_remove(postalStreet, '\nSundquist Science Complex D127'), postalStreet
)
)
# general book keeping - many of the phone numbers are not that.. if any of the
# values for phone number has no numerical values, it is just going to become
# NA
match_in <- match_in |>
mutate(
# these are mis-entries to the field.
phone = if_else(str_detect(phone, '[0-9]'), phone, NA),
# we can remove the county code...
phone = str_remove(phone, '\\[1\\] '),
# some entries have multiple phones, I'm not convinved anyone is going
# to call a curator anyways... Let's remove the send. Note we left these
# intentionally in the last call to use them as a split pattern .
phone = str_split_i(phone, '\\[1\\] ', 1),
# extract extension info to patch it back on as required.
ext = str_extract(str_split_i(phone, 'ext', 2), '[0-9].*'),
phone = str_extract(str_split_i(phone, 'ext', 1), '[0-9].*'),
# collapse everything into a string of 9 numbers
phone = str_remove_all(phone, ' |-'),
# time to put it back together.
phone =
paste0(
'(',
str_sub(phone, 1, 3), ') ',
str_sub(phone, 4, 6), '-',
str_sub(phone, 7, 10)
),
phone = na_if(phone, '(NA) NA-NA'),
phone = if_else(is.na(ext), phone, paste0(phone, ' ext. ', ext))
) |>
# replace the full state names with their abbreviations
left_join(
tigris::states() |>
sf::st_drop_geometry() |>
select(STUSPS, NAME),
by = c('postalState' = 'NAME')
) |>
select(-n, -ext, -postalState, postalState = STUSPS) |>
relocate(postalState, .after = postalCity)
write.csv(match_in, '../data/Contacts/IHContacts.csv', row.names = F)
?kable
?kableExtra
png_files <- list.files(
'../results/Plots/MarkovChain',
pattern = "png$", full.names = TRUE
)
setwd('~/Documents/assoRted/EstimatingSeedMarketSize/scripts')
png_files <- list.files(
'../results/Plots/MarkovChain',
pattern = "png$", full.names = TRUE
)
gifski::gifski(
png_files,
gif_file = '~/Documents/assoRted/SeedMarketSizingTalk/images/MarkovChains.gif',
width = 200, height = 200, delay = 2)
gifski::gifski(
png_files,
gif_file = '~/Documents/assoRted/SeedMarketSizingTalk/images/MarkovChains.gif',
delay = 2)
gifski::gifski(
png_files,
gif_files = 'boop.gif'
# gif_file = '~/Documents/assoRted/SeedMarketSizingTalk/images/MarkovChains.gif',
delay = 2)
gifski::gifski(
png_files,
gif_files = 'boop.gif',
# gif_file = '~/Documents/assoRted/SeedMarketSizingTalk/images/MarkovChains.gif',
delay = 2)
gifski::gifski(
png_files,
gif_file = 'boop.gif',
# gif_file = '~/Documents/assoRted/SeedMarketSizingTalk/images/MarkovChains.gif',
delay = 2)
?export_graph
#' @param x the output from `classifyPtsMarkov`
#' @param node_clrs A character vector of length 2. diagrammeR supports only X11 or html colors.
#'  On occasion an X11 colors matches a base R color, but not all base R colors are X11. The first color should be for the first column of the `classifyPtsMarkov` [['steadyStates']] output, the second color for the second column.
#' @param edge_clrs A character vector of length 4. The first element is a color from the transmission probabilities from node 1 to 2, the second from 2 to 1, the third element from 1 to 1, and the fourth from 4 to 4.
#' @param ... further arguments passed to `?DiagrammeR::export_graph` to save the plot on disk.
#'
#' @examples
#' node_clrs <- c('#4A001F', '#62BEC1')
#' edge_clrs <- c('#F5CDA7', '#2E0219', '#F50066', '#C5E7E8')
#'
dia_wrapper <- function(x, node_clrs, edge_clrs, ...){
if(missing(node_clrs)){node_clrs <- c()}
if(missing(edge_clrs)){edge_clrs <- c()}
ss <- round(x[['steadyStates']], 3)
tm <- round(x[['chain']]@transitionMatrix, 3)
a_graph <- DiagrammeR::create_graph() |>
DiagrammeR::add_node( # this is node 1 # above to above
label = 'above',
node_aes = DiagrammeR::node_aes(
color = node_clrs[1],
fillcolor = node_clrs[1],
fontcolor = "gray50",
xlabel = c(ss[,1]),
height = ss[,1]
)
) |>
DiagrammeR::add_node(
label = 'below',
node_aes = DiagrammeR::node_aes(
color = node_clrs[2],
fillcolor = node_clrs[2],
fontcolor = "gray50",
xlabel = c(ss[,2]),
height = ss[,2]
)) |>
DiagrammeR::add_edge(
from = 1, to = 2,
edge_aes = DiagrammeR::edge_aes(
color = edge_clrs[1],
fontcolor =  edge_clrs[1],
label = c(tm[1,2]),
penwidth = tm[1,2]
)) |>
DiagrammeR::add_edge(
from = 2, to = 1,
edge_aes = DiagrammeR::edge_aes(
color = edge_clrs[2],
fontcolor = edge_clrs[2],
label = c(tm[2,1]),
penwidth = tm[2,1]
)) |>
DiagrammeR::add_edge(
from = 1, to = 1,
edge_aes = DiagrammeR::edge_aes(
color = edge_clrs[3],
fontcolor =  edge_clrs[3],
label = c(tm[1,1]),
penwidth = tm[1,1]
)) |>
DiagrammeR::add_edge(
from = 2, to = 2,
edge_aes = DiagrammeR::edge_aes(
label = c(tm[2,2]),
penwidth = tm[2,2],
color = edge_clrs[4],
fontcolor =  edge_clrs[4]
))
DiagrammeR::export_graph(
a_graph,
file_type = "PNG",
title = x[['REG_NAME']][1],
file_name = file.path(
'..', 'results', 'Plots', 'MarkovChain',
paste0(gsub(' ', '_', x[['REG_NAME']][1]), '.png'))
)
}
lapply(output,
dia_wrapper, node_clrs = node_clrs, edge_clrs = edge_clrs,
file_type = 'png', width = 400, height = 140)
library(markovchain)
library(tidyverse)
setwd('~/Documents/assoRted/EstimatingSeedMarketSize/scripts')
source('functions.R')
annual <- read.csv('../data/processed/NoFires-TotalArea_byDOIRegion.csv')
annual <- filter(annual, FIRE_YEAR  > 1998)
annual <- split(annual, f = annual$REG_NAME)
x <- classifyPtsMarkov(ann_cgb, colname = 'TotalArea_Acre', w = 1, type = 'g')
png_files <- list.files(
'../results/Plots/MarkovChain',
pattern = "png$", full.names = TRUE
)
gifski::gifski(
png_files,
gif_file = 'boop.gif',
# gif_file = '~/Documents/assoRted/SeedMarketSizingTalk/images/MarkovChains.gif',
delay = 2)
png_files
gifski::gifski(
png_files,
gif_file = '~/Documents/assoRted/SeedMarketSizingTalk/images/MarkovChains.gif',
delay = 2)
#' @param x the output from `classifyPtsMarkov`
#' @param node_clrs A character vector of length 2. diagrammeR supports only X11 or html colors.
#'  On occasion an X11 colors matches a base R color, but not all base R colors are X11. The first color should be for the first column of the `classifyPtsMarkov` [['steadyStates']] output, the second color for the second column.
#' @param edge_clrs A character vector of length 4. The first element is a color from the transmission probabilities from node 1 to 2, the second from 2 to 1, the third element from 1 to 1, and the fourth from 4 to 4.
#' @param ... further arguments passed to `?DiagrammeR::export_graph` to save the plot on disk.
#'
#' @examples
#' node_clrs <- c('#4A001F', '#62BEC1')
#' edge_clrs <- c('#F5CDA7', '#2E0219', '#F50066', '#C5E7E8')
#'
dia_wrapper <- function(x, node_clrs, edge_clrs, ...){
if(missing(node_clrs)){node_clrs <- c()}
if(missing(edge_clrs)){edge_clrs <- c()}
ss <- round(x[['steadyStates']], 3)
tm <- round(x[['chain']]@transitionMatrix, 3)
a_graph <- DiagrammeR::create_graph() |>
DiagrammeR::add_node( # this is node 1 # above to above
label = 'above',
node_aes = DiagrammeR::node_aes(
color = node_clrs[1],
fillcolor = node_clrs[1],
fontcolor = "gray50",
xlabel = c(ss[,1]),
height = ss[,1]
)
) |>
DiagrammeR::add_node(
label = 'below',
node_aes = DiagrammeR::node_aes(
color = node_clrs[2],
fillcolor = node_clrs[2],
fontcolor = "gray50",
xlabel = c(ss[,2]),
height = ss[,2]
)) |>
DiagrammeR::add_edge(
from = 1, to = 2,
edge_aes = DiagrammeR::edge_aes(
color = edge_clrs[1],
fontcolor =  edge_clrs[1],
label = c(tm[1,2]),
penwidth = tm[1,2]
)) |>
DiagrammeR::add_edge(
from = 2, to = 1,
edge_aes = DiagrammeR::edge_aes(
color = edge_clrs[2],
fontcolor = edge_clrs[2],
label = c(tm[2,1]),
penwidth = tm[2,1]
)) |>
DiagrammeR::add_edge(
from = 1, to = 1,
edge_aes = DiagrammeR::edge_aes(
color = edge_clrs[3],
fontcolor =  edge_clrs[3],
label = c(tm[1,1]),
penwidth = tm[1,1]
)) |>
DiagrammeR::add_edge(
from = 2, to = 2,
edge_aes = DiagrammeR::edge_aes(
label = c(tm[2,2]),
penwidth = tm[2,2],
color = edge_clrs[4],
fontcolor =  edge_clrs[4]
))
DiagrammeR::export_graph(
a_graph,
title = x[['REG_NAME']][1],
file_name = file.path(
'..', 'results', 'Plots', 'MarkovChain',
paste0(gsub(' ', '_', x[['REG_NAME']][1]), '.png'))
)
}
#' @param x the output from `classifyPtsMarkov`
#' @param node_clrs A character vector of length 2. diagrammeR supports only X11 or html colors.
#'  On occasion an X11 colors matches a base R color, but not all base R colors are X11. The first color should be for the first column of the `classifyPtsMarkov` [['steadyStates']] output, the second color for the second column.
#' @param edge_clrs A character vector of length 4. The first element is a color from the transmission probabilities from node 1 to 2, the second from 2 to 1, the third element from 1 to 1, and the fourth from 4 to 4.
#' @param ... further arguments passed to `?DiagrammeR::export_graph` to save the plot on disk.
#'
#' @examples
#' node_clrs <- c('#4A001F', '#62BEC1')
#' edge_clrs <- c('#F5CDA7', '#2E0219', '#F50066', '#C5E7E8')
#'
dia_wrapper <- function(x, node_clrs, edge_clrs, ...){
if(missing(node_clrs)){node_clrs <- c()}
if(missing(edge_clrs)){edge_clrs <- c()}
ss <- round(x[['steadyStates']], 3)
tm <- round(x[['chain']]@transitionMatrix, 3)
a_graph <- DiagrammeR::create_graph() |>
DiagrammeR::add_node( # this is node 1 # above to above
label = 'above',
node_aes = DiagrammeR::node_aes(
color = node_clrs[1],
fillcolor = node_clrs[1],
fontcolor = "gray50",
xlabel = c(ss[,1]),
height = ss[,1]
)
) |>
DiagrammeR::add_node(
label = 'below',
node_aes = DiagrammeR::node_aes(
color = node_clrs[2],
fillcolor = node_clrs[2],
fontcolor = "gray50",
xlabel = c(ss[,2]),
height = ss[,2]
)) |>
DiagrammeR::add_edge(
from = 1, to = 2,
edge_aes = DiagrammeR::edge_aes(
color = edge_clrs[1],
fontcolor =  edge_clrs[1],
label = c(tm[1,2]),
penwidth = tm[1,2]
)) |>
DiagrammeR::add_edge(
from = 2, to = 1,
edge_aes = DiagrammeR::edge_aes(
color = edge_clrs[2],
fontcolor = edge_clrs[2],
label = c(tm[2,1]),
penwidth = tm[2,1]
)) |>
DiagrammeR::add_edge(
from = 1, to = 1,
edge_aes = DiagrammeR::edge_aes(
color = edge_clrs[3],
fontcolor =  edge_clrs[3],
label = c(tm[1,1]),
penwidth = tm[1,1]
)) |>
DiagrammeR::add_edge(
from = 2, to = 2,
edge_aes = DiagrammeR::edge_aes(
label = c(tm[2,2]),
penwidth = tm[2,2],
color = edge_clrs[4],
fontcolor =  edge_clrs[4]
))
DiagrammeR::export_graph(
a_graph,
...,
title = x[['REG_NAME']][1],
file_name = file.path(
'..', 'results', 'Plots', 'MarkovChain',
paste0(gsub(' ', '_', x[['REG_NAME']][1]), '.png'))
)
}
lapply(output,
dia_wrapper, node_clrs = node_clrs, edge_clrs = edge_clrs,
file_type = 'PNG', width = 400, height = 140)
library(markovchain)
library(tidyverse)
setwd('~/Documents/assoRted/EstimatingSeedMarketSize/scripts')
source('functions.R')
annual <- read.csv('../data/processed/NoFires-TotalArea_byDOIRegion.csv')
annual <- filter(annual, FIRE_YEAR  > 1998)
annual <- split(annual, f = annual$REG_NAME)
x <- classifyPtsMarkov(ann_cgb, colname = 'TotalArea_Acre', w = 1, type = 'g')
library(markovchain)
library(tidyverse)
setwd('~/Documents/assoRted/EstimatingSeedMarketSize/scripts')
source('functions.R')
annual <- read.csv('../data/processed/NoFires-TotalArea_byDOIRegion.csv')
annual <- filter(annual, FIRE_YEAR  > 1998)
annual <- split(annual, f = annual$REG_NAME)
x <- classifyPtsMarkov(ann_cgb, colname = 'TotalArea_Acre', w = 1, type = 'g')
output <- lapply(annual, classifyPtsMarkov, w = 1, colname = 'TotalArea_Acre' )
node_clrs <- c('#4A001F', '#62BEC1')
edge_clrs <- c('#F5CDA7', '#2E0219', '#F50066', '#C5E7E8')
lapply(output,
dia_wrapper, node_clrs = node_clrs, edge_clrs = edge_clrs,
file_type = 'PNG', width = 400, height = 140)
png_files <- list.files(
'../results/Plots/MarkovChain',
pattern = "png$", full.names = TRUE
)
gifski::gifski(
png_files,
gif_file = '~/Documents/assoRted/SeedMarketSizingTalk/images/MarkovChains.gif',
delay = 2)
