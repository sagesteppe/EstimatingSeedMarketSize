conf_lvl = 0.95)
lapply(listicle, reportBalance, yr_roll = 1)
#' 3) 'new' fresh seed which will be delivered straight from farm in Fall.
#' Despite area being the proxy for seed, and seed aging and losing it's ability to perform as well
#' in restorations, we will maintain 'area' as a constant.
#'
#' @param x Dataframe. The data set to be analysed.
#' @param yr_roll Numeric. the rolling average to apply for the analysis. Defaults to 1, which is that no rolling average is used.
#' @param interval Character Vector. The type of interval to be used for calculating distance between, defaults to 'confidence' the other option is 'prediction'.
#' @param prediction Vector. the name of the column from the fit model to use for calculating the distance between. Defaults to 'fit', other options are: 'lwr', and 'upr'.
#' @param conf_lvl Numeric. The confidence level to calculate the confidence limits at, defaults to 0.95 for a 95% confidence interval.
#' @export
reportBalance <- function(x, yr_roll, interval, prediction, conf_lvl){
if(missing(interval)){interval <- 'confidence'}
if(missing(prediction)){prediction <- 'fit'}
avg <- function(x, y){
x$roll <- data.table::frollmean(x$TotalArea_Acre, y)
return(x)
}
pred_help <- function(y, conf_lvl, interval){
mod_pred <- data.frame(
FIRE_YEAR = gr,
predict.lm(
y, gr, interval = interval, SE = TRUE, level = conf_lvl)
)
return(mod_pred)
}
rolled <- avg(x, yr_roll)
modr2 <- lm(roll ~ FIRE_YEAR, data = rolled)
gr <- data.frame(
# only operate on years within the rolling average.
FIRE_YEAR =  seq(min(rolled[!is.na(rolled$roll), 'FIRE_YEAR']),
max(rolled$FIRE_YEAR))
)
p <- pred_help(modr2, conf_lvl, interval)
ob <- AreaDeficitSummary(p, rolled)
TreatableAreaPlots(x = ob, rolled, mod = p, colname = 'fit', yr_roll = yr_roll)
}
rolled <- lapply(
listicle['Great Lakes'],
reportBalance,
yr_roll = 2,
interval = 'prediction',
prediction = 'fit',
conf_lvl = 0.95)
lapply(listicle, reportBalance, yr_roll = 1)
#' 3) 'new' fresh seed which will be delivered straight from farm in Fall.
#' Despite area being the proxy for seed, and seed aging and losing it's ability to perform as well
#' in restorations, we will maintain 'area' as a constant.
#'
#' @param x Dataframe. The data set to be analysed.
#' @param yr_roll Numeric. the rolling average to apply for the analysis. Defaults to 1, which is that no rolling average is used.
#' @param interval Character Vector. The type of interval to be used for calculating distance between, defaults to 'confidence' the other option is 'prediction'.
#' @param prediction Vector. the name of the column from the fit model to use for calculating the distance between. Defaults to 'fit', other options are: 'lwr', and 'upr'.
#' @param conf_lvl Numeric. The confidence level to calculate the confidence limits at, defaults to 0.95 for a 95% confidence interval.
#' @export
reportBalance <- function(x, yr_roll, interval, prediction, conf_lvl){
if(missing(interval)){interval <- 'confidence'}
if(missing(prediction)){prediction <- 'fit'}
avg <- function(x, y){
x$roll <- data.table::frollmean(x$TotalArea_Acre, y)
return(x)
}
pred_help <- function(y, conf_lvl, interval){
mod_pred <- data.frame(
FIRE_YEAR = gr,
predict.lm(
y, gr, interval = interval, SE = TRUE, level = conf_lvl)
)
return(mod_pred)
}
rolled <- avg(x, yr_roll)
modr2 <- lm(roll ~ FIRE_YEAR, data = rolled)
gr <- data.frame(
# only operate on years within the rolling average.
FIRE_YEAR =  seq(min(rolled[!is.na(rolled$roll), 'FIRE_YEAR']),
max(rolled$FIRE_YEAR))
)
p <- pred_help(modr2, conf_lvl, interval)
ob <- AreaDeficitSummary(p, rolled)
TreatableAreaPlots(x = ob, rolled, mod = p, colname = 'fit', yr_roll = yr_roll)
}
rolled <- lapply(
listicle['Great Lakes'],
reportBalance,
yr_roll = 2,
interval = 'prediction',
prediction = 'fit',
conf_lvl = 0.95)
lapply(listicle, reportBalance, yr_roll = 1)
rolled <- lapply(
listicle['Great Lakes'],
reportBalance,
yr_roll = 2,
interval = 'prediction',
prediction = 'fit',
conf_lvl = 0.95)
lapply(listicle, reportBalance, yr_roll = 1)
lapply(listicle, reportBalance, yr_roll = 1, conf_lvl = 0.95)
#' 3) 'new' fresh seed which will be delivered straight from farm in Fall.
#' Despite area being the proxy for seed, and seed aging and losing it's ability to perform as well
#' in restorations, we will maintain 'area' as a constant.
#'
#' @param x Dataframe. The data set to be analysed.
#' @param yr_roll Numeric. the rolling average to apply for the analysis. Defaults to 1, which is that no rolling average is used.
#' @param interval Character Vector. The type of interval to be used for calculating distance between, defaults to 'confidence' the other option is 'prediction'.
#' @param prediction Vector. the name of the column from the fit model to use for calculating the distance between. Defaults to 'fit', other options are: 'lwr', and 'upr'.
#' @param conf_lvl Numeric. The confidence level to calculate the confidence limits at, defaults to 0.95 for a 95% confidence interval.
#' @export
reportBalance <- function(x, yr_roll, interval, prediction, conf_lvl){
if(missing(interval)){interval <- 'confidence'}
if(missing(prediction)){prediction <- 'fit'}
if(missing(conf_lvl)){conf_lvl <- 0.95}
avg <- function(x, y){
x$roll <- data.table::frollmean(x$TotalArea_Acre, y)
return(x)
}
pred_help <- function(y, conf_lvl, interval){
mod_pred <- data.frame(
FIRE_YEAR = gr,
predict.lm(
y, gr, interval = interval, SE = TRUE, level = conf_lvl)
)
return(mod_pred)
}
rolled <- avg(x, yr_roll)
modr2 <- lm(roll ~ FIRE_YEAR, data = rolled)
gr <- data.frame(
# only operate on years within the rolling average.
FIRE_YEAR =  seq(min(rolled[!is.na(rolled$roll), 'FIRE_YEAR']),
max(rolled$FIRE_YEAR))
)
p <- pred_help(modr2, conf_lvl, interval)
ob <- AreaDeficitSummary(p, rolled)
TreatableAreaPlots(x = ob, rolled, mod = p, colname = 'fit', yr_roll = yr_roll)
}
rolled <- lapply(
listicle['Great Lakes'],
reportBalance,
yr_roll = 2,
interval = 'prediction',
prediction = 'fit',
conf_lvl = 0.95)
rolled <- lapply(
listicle['Great Lakes'],
reportBalance,
yr_roll = 2,
interval = 'prediction',
prediction = 'upr',
conf_lvl = 0.95)
lapply(listicle, reportBalance, yr_roll = 1, conf_lvl = 0.95)
#' How much of an area can be seeded each year?
#'
#' @description Calculate the amount of seed in warehouses, and how much of an area can be treated
#' based on a fit model and observed differences.
#' @param x output of `pred_help`
#' @param
#' @param rolled
AreaDeficitSummary <- function(x, rolled, prediction){
prediction <- dplyr::enquo(prediction)
rolled <- dplyr::left_join(dplyr::select(x, FIRE_YEAR, fit), rolled, by = join_by(FIRE_YEAR))
AreaDeficit <- rolled |>
dplyr::select(FIRE_YEAR, !!prediction, TotalArea_Acre)
AreaDeficit <- data.frame(
AreaDeficit,
Surplus = NA,
Warehouse = NA,
AnnualDeficit = NA,
ExcessArea = NA,
Treatable = NA
)
for (i in seq_along(1:nrow(AreaDeficit))){
## This is the amount of area which burned which is above the regression line fit.
AreaDeficit$AnnualDeficit[i] <- AreaDeficit$TotalArea_Acre[i] - AreaDeficit$fit[i]
if(AreaDeficit$AnnualDeficit[i] < 0){AreaDeficit$AnnualDeficit[i] <- 0}
## This is the amount of area seed produced in a year with less burn than regression fit.
AreaDeficit$Surplus[i] <- AreaDeficit$fit[i] - AreaDeficit$TotalArea_Acre[i]
if(AreaDeficit$Surplus[i] < 1){AreaDeficit$Surplus[i] <- 0}
# This is the amount of seed being pulled from warehouse, and how much is left at
# years end.
AreaDeficit$Warehouse[i] <- AreaDeficit$fit[i] - AreaDeficit$TotalArea_Acre[i]
if(AreaDeficit$Warehouse[i] < 1){AreaDeficit$Warehouse[i] <- 0}
##
if(i > 1){
AreaDeficit$Warehouse[i] <-
(AreaDeficit$Warehouse[i] + AreaDeficit$Warehouse[i-1]) - AreaDeficit$AnnualDeficit[i]
}
## combining fresh harvest and warehoused seed is not always enough to treat all areas
# how much excess area do we have?
if(AreaDeficit$Warehouse[i] < 0){AreaDeficit$ExcessArea[i] <- abs(AreaDeficit$Warehouse[i])}
if(AreaDeficit$Warehouse[i] < 1){AreaDeficit$Warehouse[i] <- 0}
# now how much area can be treated.
AreaDeficit$Treatable[i] <- AreaDeficit$TotalArea_Acre[i] - AreaDeficit$ExcessArea[i]
}
return(AreaDeficit)
}
#' 3) 'new' fresh seed which will be delivered straight from farm in Fall.
#' Despite area being the proxy for seed, and seed aging and losing it's ability to perform as well
#' in restorations, we will maintain 'area' as a constant.
#'
#' @param x Dataframe. The data set to be analysed.
#' @param yr_roll Numeric. the rolling average to apply for the analysis. Defaults to 1, which is that no rolling average is used.
#' @param interval Character Vector. The type of interval to be used for calculating distance between, defaults to 'confidence' the other option is 'prediction'.
#' @param prediction Vector. the name of the column from the fit model to use for calculating the distance between. Defaults to 'fit', other options are: 'lwr', and 'upr'.
#' @param conf_lvl Numeric. The confidence level to calculate the confidence limits at, defaults to 0.95 for a 95% confidence interval.
#' @export
reportBalance <- function(x, yr_roll, interval, prediction, conf_lvl){
if(missing(interval)){interval <- 'confidence'}
if(missing(prediction)){prediction <- 'fit'}
if(missing(conf_lvl)){conf_lvl <- 0.95}
avg <- function(x, y){
x$roll <- data.table::frollmean(x$TotalArea_Acre, y)
return(x)
}
pred_help <- function(y, conf_lvl, interval){
mod_pred <- data.frame(
FIRE_YEAR = gr,
predict.lm(
y, gr, interval = interval, SE = TRUE, level = conf_lvl)
)
return(mod_pred)
}
rolled <- avg(x, yr_roll)
modr2 <- lm(roll ~ FIRE_YEAR, data = rolled)
gr <- data.frame(
# only operate on years within the rolling average.
FIRE_YEAR =  seq(min(rolled[!is.na(rolled$roll), 'FIRE_YEAR']),
max(rolled$FIRE_YEAR))
)
p <- pred_help(modr2, conf_lvl, interval)
ob <- AreaDeficitSummary(p, rolled)
TreatableAreaPlots(x = ob, rolled, mod = p, colname = 'fit', yr_roll = yr_roll)
}
#' 3) 'new' fresh seed which will be delivered straight from farm in Fall.
#' Despite area being the proxy for seed, and seed aging and losing it's ability to perform as well
#' in restorations, we will maintain 'area' as a constant.
#'
#' @param x Dataframe. The data set to be analysed.
#' @param yr_roll Numeric. the rolling average to apply for the analysis. Defaults to 1, which is that no rolling average is used.
#' @param interval Character Vector. The type of interval to be used for calculating distance between, defaults to 'confidence' the other option is 'prediction'.
#' @param prediction Vector. the name of the column from the fit model to use for calculating the distance between. Defaults to 'fit', other options are: 'lwr', and 'upr'.
#' @param conf_lvl Numeric. The confidence level to calculate the confidence limits at, defaults to 0.95 for a 95% confidence interval.
#' @export
reportBalance <- function(x, yr_roll, interval, prediction, conf_lvl){
if(missing(interval)){interval <- 'confidence'}
if(missing(prediction)){prediction <- 'fit'}
if(missing(conf_lvl)){conf_lvl <- 0.95}
avg <- function(x, y){
x$roll <- data.table::frollmean(x$TotalArea_Acre, y)
return(x)
}
pred_help <- function(y, conf_lvl, interval){
mod_pred <- data.frame(
FIRE_YEAR = gr,
predict.lm(
y, gr, interval = interval, SE = TRUE, level = conf_lvl)
)
return(mod_pred)
}
rolled <- avg(x, yr_roll)
modr2 <- lm(roll ~ FIRE_YEAR, data = rolled)
gr <- data.frame(
# only operate on years within the rolling average.
FIRE_YEAR =  seq(min(rolled[!is.na(rolled$roll), 'FIRE_YEAR']),
max(rolled$FIRE_YEAR))
)
p <- pred_help(modr2, conf_lvl, interval)
ob <- AreaDeficitSummary(p, rolled)
TreatableAreaPlots(x = ob, rolled, mod = p, colname = 'fit', yr_roll = yr_roll)
}
rolled <- lapply(
listicle['Great Lakes'],
reportBalance,
yr_roll = 2,
interval = 'prediction',
prediction = 'fit',
conf_lvl = 0.95)
lapply(listicle, reportBalance, yr_roll = 1, conf_lvl = 0.95)
#' 3) 'new' fresh seed which will be delivered straight from farm in Fall.
#' Despite area being the proxy for seed, and seed aging and losing it's ability to perform as well
#' in restorations, we will maintain 'area' as a constant.
#'
#' @param x Dataframe. The data set to be analysed.
#' @param yr_roll Numeric. the rolling average to apply for the analysis. Defaults to 1, which is that no rolling average is used.
#' @param interval Character Vector. The type of interval to be used for calculating distance between, defaults to 'confidence' the other option is 'prediction'.
#' @param prediction Vector. the name of the column from the fit model to use for calculating the distance between. Defaults to 'fit', other options are: 'lwr', and 'upr'.
#' @param conf_lvl Numeric. The confidence level to calculate the confidence limits at, defaults to 0.95 for a 95% confidence interval.
#' @export
reportBalance <- function(x, yr_roll, interval, prediction, conf_lvl){
if(missing(interval)){interval <- 'confidence'}
if(missing(prediction)){prediction <- 'fit'}
if(missing(conf_lvl)){conf_lvl <- 0.95}
avg <- function(x, y){
x$roll <- data.table::frollmean(x$TotalArea_Acre, y)
return(x)
}
pred_help <- function(y, conf_lvl, interval){
mod_pred <- data.frame(
FIRE_YEAR = gr,
predict.lm(
y, gr, interval = interval, SE = TRUE, level = conf_lvl)
)
return(mod_pred)
}
rolled <- avg(x, yr_roll)
modr2 <- lm(roll ~ FIRE_YEAR, data = rolled)
gr <- data.frame(
# only operate on years within the rolling average.
FIRE_YEAR =  seq(min(rolled[!is.na(rolled$roll), 'FIRE_YEAR']),
max(rolled$FIRE_YEAR))
)
p <- pred_help(modr2, conf_lvl, interval)
ob <- AreaDeficitSummary(p, rolled)
TreatableAreaPlots(x = ob, rolled, mod = p, colname = 'fit', yr_roll = yr_roll)
}
rolled <- lapply(
listicle['Great Lakes'],
reportBalance,
yr_roll = 2,
interval = 'prediction',
prediction = 'fit',
conf_lvl = 0.95)
#' 3) 'new' fresh seed which will be delivered straight from farm in Fall.
#' Despite area being the proxy for seed, and seed aging and losing it's ability to perform as well
#' in restorations, we will maintain 'area' as a constant.
#'
#' @param x Dataframe. The data set to be analysed.
#' @param yr_roll Numeric. the rolling average to apply for the analysis. Defaults to 1, which is that no rolling average is used.
#' @param interval Character Vector. The type of interval to be used for calculating distance between, defaults to 'confidence' the other option is 'prediction'.
#' @param prediction Vector. the name of the column from the fit model to use for calculating the distance between. Defaults to 'fit', other options are: 'lwr', and 'upr'.
#' @param conf_lvl Numeric. The confidence level to calculate the confidence limits at, defaults to 0.95 for a 95% confidence interval.
#' @export
reportBalance <- function(x, yr_roll, interval, prediction, conf_lvl){
if(missing(interval)){interval <- 'confidence'}
if(missing(prediction)){prediction <- 'fit'}
if(missing(conf_lvl)){conf_lvl <- 0.95}
avg <- function(x, y){
x$roll <- data.table::frollmean(x$TotalArea_Acre, y)
return(x)
}
pred_help <- function(y, conf_lvl, interval){
mod_pred <- data.frame(
FIRE_YEAR = gr,
predict.lm(
y, gr, interval = interval, SE = TRUE, level = conf_lvl)
)
return(mod_pred)
}
rolled <- avg(x, yr_roll)
modr2 <- lm(roll ~ FIRE_YEAR, data = rolled)
gr <- data.frame(
# only operate on years within the rolling average.
FIRE_YEAR =  seq(min(rolled[!is.na(rolled$roll), 'FIRE_YEAR']),
max(rolled$FIRE_YEAR))
)
p <- pred_help(modr2, conf_lvl, interval)
ob <- AreaDeficitSummary(p, rolled, prediction)
TreatableAreaPlots(x = ob, rolled, mod = p, colname = 'fit', yr_roll = yr_roll)
}
rolled <- lapply(
listicle['Great Lakes'],
reportBalance,
yr_roll = 2,
interval = 'prediction',
prediction = 'fit',
conf_lvl = 0.95)
lapply(listicle, reportBalance, yr_roll = 1, conf_lvl = 0.95)
#' How much of an area can be seeded each year?
#'
#' @description Calculate the amount of seed in warehouses, and how much of an area can be treated
#' based on a fit model and observed differences.
#' @param x output of `pred_help`
#' @param prediction
#' @param rolled
AreaDeficitSummary <- function(x, rolled, prediction){
prediction <- dplyr::enquo(prediction)
rolled <- dplyr::left_join(dplyr::select(x, dplyr::all_of(FIRE_YEAR, fit)), rolled, by = join_by(FIRE_YEAR))
AreaDeficit <- rolled |>
dplyr::select(FIRE_YEAR, !!prediction, TotalArea_Acre)
AreaDeficit <- data.frame(
AreaDeficit,
Surplus = NA,
Warehouse = NA,
AnnualDeficit = NA,
ExcessArea = NA,
Treatable = NA
)
for (i in seq_along(1:nrow(AreaDeficit))){
## This is the amount of area which burned which is above the regression line fit.
AreaDeficit$AnnualDeficit[i] <- AreaDeficit$TotalArea_Acre[i] - AreaDeficit$fit[i]
if(AreaDeficit$AnnualDeficit[i] < 0){AreaDeficit$AnnualDeficit[i] <- 0}
## This is the amount of area seed produced in a year with less burn than regression fit.
AreaDeficit$Surplus[i] <- AreaDeficit$fit[i] - AreaDeficit$TotalArea_Acre[i]
if(AreaDeficit$Surplus[i] < 1){AreaDeficit$Surplus[i] <- 0}
# This is the amount of seed being pulled from warehouse, and how much is left at
# years end.
AreaDeficit$Warehouse[i] <- AreaDeficit$fit[i] - AreaDeficit$TotalArea_Acre[i]
if(AreaDeficit$Warehouse[i] < 1){AreaDeficit$Warehouse[i] <- 0}
##
if(i > 1){
AreaDeficit$Warehouse[i] <-
(AreaDeficit$Warehouse[i] + AreaDeficit$Warehouse[i-1]) - AreaDeficit$AnnualDeficit[i]
}
## combining fresh harvest and warehoused seed is not always enough to treat all areas
# how much excess area do we have?
if(AreaDeficit$Warehouse[i] < 0){AreaDeficit$ExcessArea[i] <- abs(AreaDeficit$Warehouse[i])}
if(AreaDeficit$Warehouse[i] < 1){AreaDeficit$Warehouse[i] <- 0}
# now how much area can be treated.
AreaDeficit$Treatable[i] <- AreaDeficit$TotalArea_Acre[i] - AreaDeficit$ExcessArea[i]
}
return(AreaDeficit)
}
lapply(listicle, reportBalance, yr_roll = 1, conf_lvl = 0.95)
#' How much of an area can be seeded each year?
#'
#' @description Calculate the amount of seed in warehouses, and how much of an area can be treated
#' based on a fit model and observed differences.
#' @param x output of `pred_help`
#' @param prediction
#' @param rolled
AreaDeficitSummary <- function(x, rolled, prediction){
prediction <- dplyr::enquo(prediction)
rolled <- dplyr::left_join(dplyr::select(x, dplyr::all_of(FIRE_YEAR, prediction)), rolled, by = join_by(FIRE_YEAR))
AreaDeficit <- rolled |>
dplyr::select(FIRE_YEAR, !!prediction, TotalArea_Acre)
AreaDeficit <- data.frame(
AreaDeficit,
Surplus = NA,
Warehouse = NA,
AnnualDeficit = NA,
ExcessArea = NA,
Treatable = NA
)
for (i in seq_along(1:nrow(AreaDeficit))){
## This is the amount of area which burned which is above the regression line fit.
AreaDeficit$AnnualDeficit[i] <- AreaDeficit$TotalArea_Acre[i] - AreaDeficit$fit[i]
if(AreaDeficit$AnnualDeficit[i] < 0){AreaDeficit$AnnualDeficit[i] <- 0}
## This is the amount of area seed produced in a year with less burn than regression fit.
AreaDeficit$Surplus[i] <- AreaDeficit$fit[i] - AreaDeficit$TotalArea_Acre[i]
if(AreaDeficit$Surplus[i] < 1){AreaDeficit$Surplus[i] <- 0}
# This is the amount of seed being pulled from warehouse, and how much is left at
# years end.
AreaDeficit$Warehouse[i] <- AreaDeficit$fit[i] - AreaDeficit$TotalArea_Acre[i]
if(AreaDeficit$Warehouse[i] < 1){AreaDeficit$Warehouse[i] <- 0}
##
if(i > 1){
AreaDeficit$Warehouse[i] <-
(AreaDeficit$Warehouse[i] + AreaDeficit$Warehouse[i-1]) - AreaDeficit$AnnualDeficit[i]
}
## combining fresh harvest and warehoused seed is not always enough to treat all areas
# how much excess area do we have?
if(AreaDeficit$Warehouse[i] < 0){AreaDeficit$ExcessArea[i] <- abs(AreaDeficit$Warehouse[i])}
if(AreaDeficit$Warehouse[i] < 1){AreaDeficit$Warehouse[i] <- 0}
# now how much area can be treated.
AreaDeficit$Treatable[i] <- AreaDeficit$TotalArea_Acre[i] - AreaDeficit$ExcessArea[i]
}
return(AreaDeficit)
}
lapply(listicle, reportBalance, yr_roll = 2)
rolled <- lapply(
listicle['Great Lakes'],
reportBalance,
yr_roll = 2,
interval = 'prediction',
prediction = 'fit',
conf_lvl = 0.95)
#' How much of an area can be seeded each year?
#'
#' @description Calculate the amount of seed in warehouses, and how much of an area can be treated
#' based on a fit model and observed differences.
#' @param x output of `pred_help`
#' @param prediction
#' @param rolled
AreaDeficitSummary <- function(x, rolled, prediction){
prediction <- dplyr::enquo(prediction)
rolled <- dplyr::left_join(dplyr::select(x, FIRE_YEAR, fit), rolled, by = join_by(FIRE_YEAR))
AreaDeficit <- rolled |>
dplyr::select(FIRE_YEAR, !!prediction, TotalArea_Acre)
AreaDeficit <- data.frame(
AreaDeficit,
Surplus = NA,
Warehouse = NA,
AnnualDeficit = NA,
ExcessArea = NA,
Treatable = NA
)
for (i in seq_along(1:nrow(AreaDeficit))){
## This is the amount of area which burned which is above the regression line fit.
AreaDeficit$AnnualDeficit[i] <- AreaDeficit$TotalArea_Acre[i] - AreaDeficit$fit[i]
if(AreaDeficit$AnnualDeficit[i] < 0){AreaDeficit$AnnualDeficit[i] <- 0}
## This is the amount of area seed produced in a year with less burn than regression fit.
AreaDeficit$Surplus[i] <- AreaDeficit$fit[i] - AreaDeficit$TotalArea_Acre[i]
if(AreaDeficit$Surplus[i] < 1){AreaDeficit$Surplus[i] <- 0}
# This is the amount of seed being pulled from warehouse, and how much is left at
# years end.
AreaDeficit$Warehouse[i] <- AreaDeficit$fit[i] - AreaDeficit$TotalArea_Acre[i]
if(AreaDeficit$Warehouse[i] < 1){AreaDeficit$Warehouse[i] <- 0}
##
if(i > 1){
AreaDeficit$Warehouse[i] <-
(AreaDeficit$Warehouse[i] + AreaDeficit$Warehouse[i-1]) - AreaDeficit$AnnualDeficit[i]
}
## combining fresh harvest and warehoused seed is not always enough to treat all areas
# how much excess area do we have?
if(AreaDeficit$Warehouse[i] < 0){AreaDeficit$ExcessArea[i] <- abs(AreaDeficit$Warehouse[i])}
if(AreaDeficit$Warehouse[i] < 1){AreaDeficit$Warehouse[i] <- 0}
# now how much area can be treated.
AreaDeficit$Treatable[i] <- AreaDeficit$TotalArea_Acre[i] - AreaDeficit$ExcessArea[i]
}
return(AreaDeficit)
}
lapply(listicle, reportBalance, yr_roll = 1, conf_lvl = 0.95)
