markovchainSequence(
n = 10,  # number of years into future.
markovchain = fire_chain # chain object.
)
)
# will need to save this object.... A many columned csv seems fine...
}
library(markovchain)
library(tidyverse)
setwd('~/Documents/assoRted/EstimatingSeedMarketSize/scripts')
source('functions.R')
annual <- read.csv('../data/processed/NoFires-TotalArea_byDOIRegion.csv')
annual <- filter(annual, FIRE_YEAR  > 1998)
ann_cgb <- filter(annual, REG_NAME == 'Great Lakes')
x <- classifyPtsMarkov(ann_cgb)
View(x)
#' and classify the training data as being in one of three or optionally three classes.
#' 'below' for all points beneath the lower confidence limit, 'around' for
#' points within the confidence limit, and 'upper' for points above the upper 95% confidence limit.
#' @param x Dataframe. The data set to be analysed.
#' @param yr_roll Numeric. the rolling average to apply for the analysis.
#' Defaults to 1, which is that no rolling average is used.
#' @param interval Character Vector. The type of interval to be used for
#' calculating distance between, defaults to 'confidence' the other option is 'prediction'.
#' @param conf_lvl Numeric. The confidence level to calculate the confidence limits at, defaults to 0.95 for a 95% confidence interval.
#' @export
classifyPtsMarkov <- function(x, yr_roll, interval, conf_lvl, prediction){
if(missing(interval)){interval <- 'confidence'}
if(missing(prediction)){prediction <- 'fit'}
if(missing(conf_lvl)){conf_lvl <- 0.95}
if(missing(yr_roll)){yr_roll <- 1}
rolled <- avg(x, yr_roll)
modr2 <- lm(roll ~ FIRE_YEAR, data = rolled)
gr <- data.frame(
# only operate on years within the rolling average.
FIRE_YEAR =  seq(min(rolled[!is.na(rolled$roll), 'FIRE_YEAR']),
max(rolled$FIRE_YEAR))
)
pred_help <- function(y, lvl, gr){
mod_pred <- data.frame(
FIRE_YEAR = gr,
predict.lm(
y, gr, interval = 'confidence', level = lvl)
)
return(mod_pred)
}
p <- pred_help(modr2, lvl = conf_lvl, gr)
p$observed <- x$TotalArea_Acre
state = vector(mode = 'character', length = nrow(p))
for (i in 1:nrow(p)){
if(p$observed[i] <= p$fit[i]){state[i] = 'below'}  else {state[i] = 'above'}
}
# first we need to calculate the transition probabilities between the various states.
# Doing this is not super well documented in the `markovchain` package, but the
# function `markovchainFit` will develop transition probabilities.
# The input object works in pairs, essentially position 1 x[1] is state 1, and
# position 2 x[2] is state 2, the 3rd and 4th positions refer to an entirely new
# set of observations.
mcFitMLE <- markovchain::markovchainFit(state, method = 'mle')
# we create another s4 object which the package relies on using base R's `new`
# function
fire_chain <- new(
"markovchain",
states = c('above', 'below'),
transitionMatrix = mcFitMLE[["estimate"]]@transitionMatrix, # access the transition matrix
name = "Fire Chain - Relative to Regression fit")
# save the original data object.
# many more years are below the fire amount than are
# above the trend line is largely informed by a few large fires.
# we can repeat this process n times.
set.seed(1428)
markov_sim <- replicate(100, expr =
markovchain::markovchainSequence(
n = 10,  # number of years into future.
markovchain = fire_chain # chain object.
)
)
return(
chain = fire_chain,
steadyStates = markovchain::steadyStates(fire_chain),
markov_simulations = markov_sim
)
# will need to save this object.... A many columned csv seems fine...
}
library(markovchain)
library(tidyverse)
setwd('~/Documents/assoRted/EstimatingSeedMarketSize/scripts')
source('functions.R')
annual <- read.csv('../data/processed/NoFires-TotalArea_byDOIRegion.csv')
annual <- filter(annual, FIRE_YEAR  > 1998)
ann_cgb <- filter(annual, REG_NAME == 'Great Lakes')
x <- classifyPtsMarkov(ann_cgb)
#' and classify the training data as being in one of three or optionally three classes.
#' 'below' for all points beneath the lower confidence limit, 'around' for
#' points within the confidence limit, and 'upper' for points above the upper 95% confidence limit.
#' @param x Dataframe. The data set to be analysed.
#' @param yr_roll Numeric. the rolling average to apply for the analysis.
#' Defaults to 1, which is that no rolling average is used.
#' @param interval Character Vector. The type of interval to be used for
#' calculating distance between, defaults to 'confidence' the other option is 'prediction'.
#' @param conf_lvl Numeric. The confidence level to calculate the confidence limits at, defaults to 0.95 for a 95% confidence interval.
#' @export
classifyPtsMarkov <- function(x, yr_roll, interval, conf_lvl, prediction){
if(missing(interval)){interval <- 'confidence'}
if(missing(prediction)){prediction <- 'fit'}
if(missing(conf_lvl)){conf_lvl <- 0.95}
if(missing(yr_roll)){yr_roll <- 1}
rolled <- avg(x, yr_roll)
modr2 <- lm(roll ~ FIRE_YEAR, data = rolled)
gr <- data.frame(
# only operate on years within the rolling average.
FIRE_YEAR =  seq(min(rolled[!is.na(rolled$roll), 'FIRE_YEAR']),
max(rolled$FIRE_YEAR))
)
pred_help <- function(y, lvl, gr){
mod_pred <- data.frame(
FIRE_YEAR = gr,
predict.lm(
y, gr, interval = 'confidence', level = lvl)
)
return(mod_pred)
}
p <- pred_help(modr2, lvl = conf_lvl, gr)
p$observed <- x$TotalArea_Acre
state = vector(mode = 'character', length = nrow(p))
for (i in 1:nrow(p)){
if(p$observed[i] <= p$fit[i]){state[i] = 'below'}  else {state[i] = 'above'}
}
# first we need to calculate the transition probabilities between the various states.
# Doing this is not super well documented in the `markovchain` package, but the
# function `markovchainFit` will develop transition probabilities.
# The input object works in pairs, essentially position 1 x[1] is state 1, and
# position 2 x[2] is state 2, the 3rd and 4th positions refer to an entirely new
# set of observations.
mcFitMLE <- markovchain::markovchainFit(state, method = 'mle')
# we create another s4 object which the package relies on using base R's `new`
# function
fire_chain <- new(
"markovchain",
states = c('above', 'below'),
transitionMatrix = mcFitMLE[["estimate"]]@transitionMatrix, # access the transition matrix
name = "Fire Chain - Relative to Regression fit")
# save the original data object.
# many more years are below the fire amount than are
# above the trend line is largely informed by a few large fires.
# we can repeat this process n times.
set.seed(1428)
markov_sim <- replicate(100, expr =
markovchain::markovchainSequence(
n = 10,  # number of years into future.
markovchain = fire_chain # chain object.
)
)
return(
list(
chain = fire_chain,
steadyStates = markovchain::steadyStates(fire_chain),
markov_simulations = markov_sim
)
)
# will need to save this object.... A many columned csv seems fine...
}
x <- classifyPtsMarkov(ann_cgb)
View(x)
x[["steadyStates"]]
x[["markov_simulations"]]
save <- TRUE
x$markov_simulations
as.data.frame(x$markov_simulations)
x$markov_simulations <- as.data.frame(x$markov_simulations)
colnames(markov_simulations) <- 1:ncol(markov_simulations)
colnames(x$markov_simulations) <- 1:ncol(x$markov_simulations)
colnames(x$markov_simulations)
colnames(x$markov_simulations) <- paste0('S', 1:ncol(x$markov_simulations))
colnames(x$markov_simulations)
d = as.data.table(list(1:6/2, 3:8/4))
library(data.table)
d = as.data.table(list(1:6/2, 3:8/4))
# rollmean of single vector and single window
frollmean(d[, V1], 3)
# rollmean of single vector and single window
frollmean(d[, V1], 3, FUN = harmonic.mean)
?frollmean
# rollmean of single vector and single window
frollapply(d[, V1], 3, FUN = harmonic.mean)
?harmonic.mean
??harmonic.mean
spatstat.utils::harmonicmean()
spatstat.utils::harmonicmean
# rollmean of single vector and single window
frollapply(d[, V1], 3, FUN = spatstat.utils::harmonicmean)
# rollmean of single vector and single window
frollmean(d[, V1], 3, FUN = spatstat.utils::harmonicmean)
# rollmean of single vector and single window
frollapply(d[, V1], 3, FUN = spatstat.utils::harmonicmean)
frollmean(d[, V1], 3)
#'
#' @description This function wraps around two under laying data.table functions
#' to calculate a rolling mean of a numeric vector. It implements one of two functions,
#' either data.table::frollmean, if type = 'arithematic', or a geometric mean if
#' type = 'geometric'. The geometric mean is calculated using spatstat.utils::harmonicmean
#' wrapped within data.table::frollapply.
#' @param x Data.frame. A data frame of values
#' @param colname. Character. A Column to calculate the values on. No default, will exit function.
#' @param y Numeric. The rolling window to use for the calculation. Defaults to 3.
#' @param type Character. One of 'arithematic' or 'geometric'. Defaults to arithmetic.
avg <- function(x, y, type){
if(missing(y)){y <- 3}
if(missing(type)){type <- 'arithematic'}
if(type == 'arithmetic'){
x$roll <- data.table::frollmean(x[[colname]], y)
} else {
x$roll <- frollapply(x[[colname]], FUN = spatstat.utils::harmonicmean)
}
return(x)
}
#'
#' @description This function wraps around two under laying data.table functions
#' to calculate a rolling mean of a numeric vector. It implements one of two functions,
#' either data.table::frollmean, if type = 'arithematic', or a geometric mean if
#' type = 'geometric'. The geometric mean is calculated using spatstat.utils::harmonicmean
#' wrapped within data.table::frollapply.
#' @param x Data.frame. A data frame of values
#' @param colname. Character. A Column to calculate the values on. No default, will exit function.
#' @param y Numeric. The rolling window to use for the calculation. Defaults to 3.
#' @param type Character. One of 'arithematic' or 'geometric'. Defaults to arithmetic.
avg <- function(x, colname, y, type){
if(missing(y)){y <- 3}
if(missing(type)){type <- 'arithematic'}
if(type == 'arithmetic'){
x$roll <- data.table::frollmean(x[[colname]], y)
} else {
x$roll <- frollapply(x[[colname]], FUN = spatstat.utils::harmonicmean)
}
return(x)
}
#'
#' @description This function wraps around two under laying data.table functions
#' to calculate a rolling mean of a numeric vector. It implements one of two functions,
#' either data.table::frollmean, if type = 'arithematic', or a geometric mean if
#' type = 'geometric'. The geometric mean is calculated using spatstat.utils::harmonicmean
#' wrapped within data.table::frollapply.
#' @param x Data.frame. A data frame of values
#' @param colname. Character. A Column to calculate the values on. No default, will exit function.
#' @param w Numeric. The rolling window to use for the calculation. Defaults to 3.
#' @param type Character. One of 'arithematic' or 'geometric'. Defaults to arithmetic.
avg <- function(x, colname, w, type){
if(missing(y)){y <- 3}
if(missing(type)){type <- 'arithematic'}
if(type == 'arithmetic'){
x$roll <- data.table::frollmean(x[[colname]], w)
} else {
x$roll <- frollapply(x[[colname]], w, FUN = spatstat.utils::harmonicmean)
}
return(x)
}
avg(ann_cgb, colname = 'TotalArea_Acre', w = 5)
#'
#' @description This function wraps around two under laying data.table functions
#' to calculate a rolling mean of a numeric vector. It implements one of two functions,
#' either data.table::frollmean, if type = 'arithematic', or a geometric mean if
#' type = 'geometric'. The geometric mean is calculated using spatstat.utils::harmonicmean
#' wrapped within data.table::frollapply.
#' @param x Data.frame. A data frame of values
#' @param colname. Character. A Column to calculate the values on. No default, will exit function.
#' @param w Numeric. The rolling window to use for the calculation. Defaults to 3.
#' @param type Character. One of 'arithematic' or 'geometric'. Defaults to arithmetic.
avg <- function(x, colname, w, type){
if(missing(y)){y <- 3}
if(missing(type)){type <- 'arithematic'}
if(type == 'arithmetic'){
x$roll <- data.table::frollmean(x[[colname]], w)
} else {
x$roll <- frollapply(x[[colname]], w, FUN = spatstat.utils::harmonicmean)
}
return(x)
}
avg(ann_cgb, colname = 'TotalArea_Acre', w = 5)
#'
#' @description This function wraps around two under laying data.table functions
#' to calculate a rolling mean of a numeric vector. It implements one of two functions,
#' either data.table::frollmean, if type = 'arithematic', or a geometric mean if
#' type = 'geometric'. The geometric mean is calculated using spatstat.utils::harmonicmean
#' wrapped within data.table::frollapply.
#' @param x Data.frame. A data frame of values
#' @param colname. Character. A Column to calculate the values on. No default, will exit function.
#' @param w Numeric. The rolling window to use for the calculation. Defaults to 3.
#' @param type Character. One of 'arithematic' or 'geometric'. Defaults to arithmetic.
avg <- function(x, colname, w, type){
if(missing(w)){w <- 3}
if(missing(type)){type <- 'arithematic'}
if(type == 'arithmetic'){
x$roll <- data.table::frollmean(x[[colname]], w)
} else {
x$roll <- frollapply(x[[colname]], w, FUN = spatstat.utils::harmonicmean)
}
return(x)
}
avg(ann_cgb, colname = 'TotalArea_Acre', w = 5)
avg(ann_cgb, colname = 'TotalArea_Acre', w = 7)
avg(ann_cgb, colname = 'TotalArea_Acre', w = 3)
avg(ann_cgb, colname = 'TotalArea_Acre')
avg(ann_cgb, colname = 'TotalArea_Acre', type = 'geometric')
#'
#' @description This function wraps around two under laying data.table functions
#' to calculate a rolling mean of a numeric vector. It implements one of two functions,
#' either data.table::frollmean, if type = 'arithematic', or a geometric mean if
#' type = 'geometric'. The geometric mean is calculated using spatstat.utils::harmonicmean
#' wrapped within data.table::frollapply.
#' @param x Data.frame. A data frame of values
#' @param colname. Character. A Column to calculate the values on. No default, will exit function.
#' @param w Numeric. The rolling window to use for the calculation. Defaults to 3.
#' @param type Character. One of 'a' for arithematic or 'g' for geometric. Defaults to arithmetic.
avg <- function(x, colname, w, type){
if(missing(w)){w <- 3}
if(missing(type)){type <- 'a'}
if(type == 'a'){
x$roll <- data.table::frollmean(x[[colname]], w)
} else {
x$roll <- frollapply(x[[colname]], w, FUN = spatstat.utils::harmonicmean)
}
return(x)
}
avg(ann_cgb, colname = 'TotalArea_Acre', type = 'geometric')
paste0('roll_', type, w)
#'
#' @description This function wraps around two under laying data.table functions
#' to calculate a rolling mean of a numeric vector. It implements one of two functions,
#' either data.table::frollmean, if type = 'arithematic', or a geometric mean if
#' type = 'geometric'. The geometric mean is calculated using spatstat.utils::harmonicmean
#' wrapped within data.table::frollapply.
#' @param x Data.frame. A data frame of values
#' @param colname. Character. A Column to calculate the values on. No default, will exit function.
#' @param w Numeric. The rolling window to use for the calculation. Defaults to 3.
#' @param type Character. One of 'a' for arithematic or 'g' for geometric. Defaults to arithmetic.
avg <- function(x, colname, w, type){
if(missing(w)){w <- 3}
if(missing(type)){type <- 'a'}
outname <- paste0('roll_', type, w)
if(type == 'a'){
x$roll <- data.table::frollmean(x[[colname]], w)
} else {
x$roll <- frollapply(x[[colname]], w, FUN = spatstat.utils::harmonicmean)
}
return(x)
}
#'
#' @description This function wraps around two under laying data.table functions
#' to calculate a rolling mean of a numeric vector. It implements one of two functions,
#' either data.table::frollmean, if type = 'arithematic', or a geometric mean if
#' type = 'geometric'. The geometric mean is calculated using spatstat.utils::harmonicmean
#' wrapped within data.table::frollapply.
#' @param x Data.frame. A data frame of values
#' @param colname. Character. A Column to calculate the values on. No default, will exit function.
#' @param w Numeric. The rolling window to use for the calculation. Defaults to 3.
#' @param type Character. One of 'a' for arithematic or 'g' for geometric. Defaults to arithmetic.
avg <- function(x, colname, w, type){
if(missing(w)){w <- 3}
if(missing(type)){type <- 'a'}
outname <- paste0('roll_', type, w)
if(type == 'a'){
x['outname'] <- data.table::frollmean(x[[colname]], w)
} else {
x$roll <- frollapply(x[[colname]], w, FUN = spatstat.utils::harmonicmean)
}
return(x)
}
avg(ann_cgb, colname = 'TotalArea_Acre', type = 'geometric')
avg(ann_cgb, colname = 'TotalArea_Acre', type = 'a')
#'
#' @description This function wraps around two under laying data.table functions
#' to calculate a rolling mean of a numeric vector. It implements one of two functions,
#' either data.table::frollmean, if type = 'arithematic', or a geometric mean if
#' type = 'geometric'. The geometric mean is calculated using spatstat.utils::harmonicmean
#' wrapped within data.table::frollapply.
#' @param x Data.frame. A data frame of values
#' @param colname. Character. A Column to calculate the values on. No default, will exit function.
#' @param w Numeric. The rolling window to use for the calculation. Defaults to 3.
#' @param type Character. One of 'a' for arithematic or 'g' for geometric. Defaults to arithmetic.
avg <- function(x, colname, w, type){
if(missing(w)){w <- 3}
if(missing(type)){type <- 'a'}
outname <- paste0('roll_', type, w)
if(type == 'a'){
x[['outname']] <- data.table::frollmean(x[[colname]], w)
} else {
x$roll <- frollapply(x[[colname]], w, FUN = spatstat.utils::harmonicmean)
}
return(x)
}
avg(ann_cgb, colname = 'TotalArea_Acre', type = 'a')
#'
#' @description This function wraps around two under laying data.table functions
#' to calculate a rolling mean of a numeric vector. It implements one of two functions,
#' either data.table::frollmean, if type = 'arithematic', or a geometric mean if
#' type = 'geometric'. The geometric mean is calculated using spatstat.utils::harmonicmean
#' wrapped within data.table::frollapply.
#' @param x Data.frame. A data frame of values
#' @param colname. Character. A Column to calculate the values on. No default, will exit function.
#' @param w Numeric. The rolling window to use for the calculation. Defaults to 3.
#' @param type Character. One of 'a' for arithematic or 'g' for geometric. Defaults to arithmetic.
avg <- function(x, colname, w, type){
if(missing(w)){w <- 3}
if(missing(type)){type <- 'a'}
outname <- paste0('roll_', type, w)
if(type == 'a'){
x[[outname]] <- data.table::frollmean(x[[colname]], w)
} else {
x$roll <- frollapply(x[[colname]], w, FUN = spatstat.utils::harmonicmean)
}
return(x)
}
avg(ann_cgb, colname = 'TotalArea_Acre', type = 'a')
#'
#' @description This function wraps around two under laying data.table functions
#' to calculate a rolling mean of a numeric vector. It implements one of two functions,
#' either data.table::frollmean, if type = 'arithematic', or a geometric mean if
#' type = 'geometric'. The geometric mean is calculated using spatstat.utils::harmonicmean
#' wrapped within data.table::frollapply.
#' @param x Data.frame. A data frame of values
#' @param colname. Character. A Column to calculate the values on. No default, will exit function.
#' @param w Numeric. The rolling window to use for the calculation. Defaults to 3.
#' @param type Character. One of 'a' for arithematic or 'g' for geometric. Defaults to arithmetic.
avg <- function(x, colname, w, type){
if(missing(w)){w <- 3}
if(missing(type)){type <- 'a'}
outname <- paste0('roll_', type, w)
if(type == 'a'){
x[[outname]] <- data.table::frollmean(x[[colname]], w)
} else {
x[[outname]]  <- frollapply(x[[colname]], w, FUN = spatstat.utils::harmonicmean)
}
return(x)
}
avg(ann_cgb, colname = 'TotalArea_Acre', type = 'a')
#'
#' @description This function wraps around two under laying data.table functions
#' to calculate a rolling mean of a numeric vector. It implements one of two functions,
#' either data.table::frollmean, if type = 'arithematic', or a geometric mean if
#' type = 'geometric'. The geometric mean is calculated using spatstat.utils::harmonicmean
#' wrapped within data.table::frollapply.
#' @param x Data.frame. A data frame of values
#' @param colname. Character. A Column to calculate the values on. No default, will exit function.
#' @param w Numeric. The rolling window to use for the calculation. Defaults to 3.
#' @param type Character. One of 'a' for arithematic or 'g' for geometric. Defaults to arithmetic.
avg <- function(x, colname, w, type){
if(missing(w)){w <- 3}
if(missing(type)){type <- 'a'}
outname <- paste0('roll_', type, w)
if(type == 'a'){
x[[outname]] <- data.table::frollmean(x[[colname]], w)
} else {
x[[outname]]  <- frollapply(x[[colname]], w, FUN = spatstat.utils::harmonicmean)
}
return(x)
}
avg(ann_cgb, colname = 'TotalArea_Acre', type = 'g')
1:10
data.frame <- (
Value = 1:20,
data.frame <- (
Value = 1:20,
Value = 1:20
data.frame(
Value = 1:20,
Observation = LETTERS[1:20]
)
arith <- data.frame(
Value = 1:20,
Observation = LETTERS[1:20]
)
avg(arith, colname = 'Observation')
avg(arith, colname = 'Value')
Value = 1:20*2
1:20
1:20^2
(1:20)^2
geo <- data.frame(
Value = (1:20)^2,
Observation = LETTERS[1:20]
)
avg(arith, colname = 'Value', w = 7)
avg(geo, colname = 'Value', w = 7)
arith <- data.frame(
Value = 1:10,
Observation = LETTERS[1:10]
)
geo <- data.frame(
Value = (1:10)^2,
Observation = LETTERS[1:10]
)
avg(arith, colname = 'Value')
avg(geo, colname = 'Value', w = 5)
avg(geo, colname = 'Value', type = 'g', w = 5)
arith <- data.frame(
Value = 1:10,
Observation = LETTERS[1:10]
)
geo <- data.frame(
Value = (1:10)^2,
Observation = LETTERS[1:10]
)
avg(arith, colname = 'Value')
avg(geo, colname = 'Value', type = 'g', w = 5)
geo <- data.frame(
Value = exp(1:10),
Observation = LETTERS[1:10]
)
geo
avg(arith, colname = 'Value')
avg(geo, colname = 'Value', type = 'g', w = 5)
avg(geo, colname = 'Value', type = 'g', w = 4)
